<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>A Joint Neural Model for Information Extraction with Global Features</title>
      <link href="/2020/10/18/a-joint-neural-model-for-information-extraction-with-global-features/"/>
      <url>/2020/10/18/a-joint-neural-model-for-information-extraction-with-global-features/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020 ACL会议《A Joint Neural Model for Information Extraction with Global Features》</p><p><a href="https://www.aclweb.org/anthology/2020.acl-main.713/">论文地址</a></p></blockquote><p>该论文提出一个名为ONEIE的信息抽取框架，增加一个全局特征，在实例之间和子任务之间进行联合决策。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>大多数的信息抽取的联合学习模型使用task-specific分类对独立实体进行标记而不是使用实体之间的交互信息。论文提出名为ONEIE的端到端信息抽取框架，整个过程分为四个操作阶段：</p><ol><li>对输入语句进行编码（Embedding）；</li><li>识别句中的实体（Entity）和事件（Event）并用结点（Node）进行表示；</li><li>使用句内信息（Local classifier）计算所有结点及其连接（Link）的标签分数（Label Score）；</li><li>解码（Decoding）时使用束搜索（Beam search）找到全局最优图。</li></ol><p>在解码阶段加入全局特征（Global Feature）捕捉实例之间（cross-instance）和子任务之间（cross-subtask）的联系（Interaction）。同时ONEIE框架没有使用任何特定语言的语法特征（Language-specific feature），所以很容易适应新语言。</p><p><img src="http://note.lizhihao999.cn/notes/20201018225620.png" alt="框架示意图"></p><h1 id="2-Task"><a href="#2-Task" class="headerlink" title="2. Task"></a>2. Task</h1><ol><li><p><strong>Entity Extraction</strong></p><p>根据提前定义（Pre-defined）的实体分类识别语句中提及的实体。</p></li><li><p><strong>Relation Extraction</strong></p><p>对给定的实体对分配关系类型。</p></li><li><p><strong>Event Extraction</strong></p><p>涉及识别非结构语句中的事件触发语（Event trigger: the word or phrases that most clearly express event occurrences）及这些词语和短语的论据（Arguments: the words and phrases for participants in those events），并将这些短语根据类型和语法规则进行分类。</p><p>一个Argument可以是一个实体、时间表达式或数值等。</p></li></ol><p>对信息抽取的任务作如下规定：<br>对于给定的句子，目的是提取一个信息表示图：$G=(V,E)$，其中$V$和$E$分别表示结点集和边集。</p><p>对于任意结点$v_i=&lt;a_i, b_i, l_i&gt;\in V$表示一个实体（Entity）或事件触发器（Event trigger），其中$a$和$b$分别表示结点起始和结束词语的索引（indices），$l$表示结点类型标签（Node type label）。</p><p>对于任意边$e_{ij}=&lt;i,j,l_{ij}&gt;\in E$表示两个结点之间的关系，其中$i$和$j$分别表示两个相关结点的索引，$l_{ij}$表示关系类型。</p><h1 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3. Approach"></a>3. Approach</h1><p>ONEIE框架对给定的语句进行信息网络提取，分为以下四步：encoding，identification，classification和decoding。我们使用预训练的BERT模型进行编码，然后对语句中的实体和事件触发器进行识别。之后计算所有的结点和相关的边的类型标签分数（Type label scores）。在解码阶段，我们使用束搜索（Beam Search）探索输入语句可能的信息网络。</p><h2 id="3-1-Encoding"><a href="#3-1-Encoding" class="headerlink" title="3.1 Encoding"></a>3.1 Encoding</h2><p>输入一句包含$L$个词的语句，使用预训练的BERT模型将每个词表示为$x_i$。实验发现使用最后三层BERT在大多数的子任务上表现较好。</p><h2 id="3-2-Identification"><a href="#3-2-Identification" class="headerlink" title="3.2 Identification"></a>3.2 Identification</h2><p>这一阶段将识别句中的实体提及和事件触发器，并表示为信息网络中的结点。我们使用前馈神经网络FFN计算每个词的分数向量$\hat{y}_i=FFN(x_i)$，$\hat{y}_i$表示一个标签在目标标签集（Target tag set）中的分数。</p><p>之后使用CRF层捕捉标签之间的联系，计算tag path： $\hat{z}={\hat{z_1},…,\hat{z}_L}$ 的分数:</p><img src="http://note.lizhihao999.cn/notes/20201018231804.png" style="zoom:80%;"><p>其中$X={x_1,…,x_L}$是输入语句中每个词的向量表示，$\hat{y}<em>{i,\hat{z_i}}$是分数向量$\hat{y}_i$在第$\hat{z}<em>i$条路径的组合，$A</em>{\hat{z}</em>{i-1},\hat{z}<em>{i}}$是矩阵A中$\hat{z}</em>{i-1}$到$\hat{z}_i$的转移分数。同时，我们在A中添加两个特殊的标签$<start>,<end>$分别作为$\hat{z}<em>0$和$\hat{z}</em>{L+1}$来表示词语序列的开始和结束。</end></start></p><p>训练阶段时，我们最大化标准标签路径的对数似然估计：<br>$$<br>\log{p(z|X)}=s(X,z)-log{\sum_{\hat{z}\in Z}{e^{s(X.\hat{z})}}}<br>$$</p><p>其中$Z$是输入语句中所有可能标签路径的集合。</p><p>所以我们定义实体识别阶段的损失函数为：<br>$$<br>L^I=-\log{p(z|X)}<br>$$</p><h2 id="3-3-Classification"><a href="#3-3-Classification" class="headerlink" title="3.3 Classification"></a>3.3 Classification</h2><p>将每个识别出的结点表示为$v_i$，之后使用分离的针对特定任务的前馈神经网络来计算每个结点的标签分数：<br>$$<br>\hat{y}_{i}^{t}=FFN^t(v_i)<br>$$</p><p>其中$t$表示一个特定的任务。</p><p>为了获得$i-th$和$j-th$结点之间边的标签分数，我们连接它们的跨度表示（Span Representation），将向量表示为：<br>$$<br>\hat{y}_{k}^{t}=FFN^t(v_i,v_j)<br>$$</p><p>对于每个任务，训练目标是最小化以下交叉熵损失：<br>$$<br>L^{t}=-\frac{1}{N^t}\sum_{i=1}^{N^t}{y_i^{t}\log{\hat{y}^{t}_{i}}}<br>$$</p><p>其中，$y_i^{t}$是向量的正确标签，$N^t$是任务$t$中的实体数量。</p><p>如果忽略结点和边的内在依赖关系（Inter-dependencies），我们可以直接通过每个任务的最高分数来预测标签，之后生成局部的最佳图$\hat{G}$。最佳图$\hat{G}$分数的计算方法为：<br>$$<br>s’(\hat{G})=\sum_{t\in T}\sum_{i=1}^{N^t}{\max{\hat{y}_i^t}}<br>$$</p><p>其中，$T$是任务的集合，将$s’(\hat{G})$作为$\hat{G}$的局部分数参考。</p><h2 id="3-4-Global-Features"><a href="#3-4-Global-Features" class="headerlink" title="3.4 Global Features"></a>3.4 Global Features</h2><p>我们考虑框架中的两种类型的内部依赖：</p><ol><li><p>子任务间的作用 Cross-subtask interactions</p><p>这种依赖关系存在于实体、关系和事件之间；</p></li><li><p>实体之间的作用 Cross-instance interactions</p><p>这种依赖存在于一个句子中多个事件和/或关系的实例之间。</p></li></ol><p><img src="http://note.lizhihao999.cn/notes/20201018225648.png" alt="全局特征类型模板（Event schemas）"></p><p>我们设计一套全局特征类型模板（Event schemas）来捕捉以上两类相互作用，模型填充所有可能的类型来生成特征，并在训练过程中学习每个特征的权重。对于给定的一张图，我们将它的全局特征向量描述为：<br>$$<br>f_G={f_1(G),…,f_M(G)}<br>$$<br>其中，$M$是全局特征的数量，$f_i(\cdot)$是一个函数，对某个特征求值并返回标量。比如：<br>$$<br>f_i(G)=\begin{cases}<br>1,G,has,multiple,ATTCK,events\<br>0,otherwise<br>\end{cases}<br>$$<br>之后，ONEIE框架学习到一个权重向量$u\in \R^{M}$并且将$f(G)$和$u$的点乘作为图G的全局特征分数。将图G的局部分数和全局特征分数之和作为G的全局分数：<br>$$<br>s(G)=s’(G)+{u}{f}(G)<br>$$<br>我们假定一条语句的最佳（Gold-standard）图应该拥有最高的全局分数。所以，我们最小化该损失函数：<br>$$<br>L^{G}=s(\hat{G})-s(G)<br>$$<br>其中，$\hat{G}$是局部分类得到的图，$G$是最佳图。</p><p>最终，我们在训练中最优化如下的联合目标函数：<br>$$<br>L=L^I+\sum_{t\in{T}}{L^t}+L^{G}<br>$$</p><h2 id="3-5-Decoding"><a href="#3-5-Decoding" class="headerlink" title="3.5 Decoding"></a>3.5 Decoding</h2><p>ONEIE对所有的结点和成对的边进行联合决策，得到全局的最优图。最基本的方法是计算所有候选图的全局分数，选择分数最高的作为最终结果。为了优化复杂度，我们设计了一个以束搜索为基础的解码器（Beam search-based decoder）。</p><p><img src="http://note.lizhihao999.cn/notes/20201018225711.png" alt="解码算法示例"></p><p>对于给定的识别出的结点集$V$、所有结点的标签分数（label scores）和他们之间的成对联系执行解码，初始束集（initial beam set）为$B={K_{0}}$，$K_0$是一个零阶图。每一步$i$分为两小步，分别对结点和边进行扩展：</p><ol><li><p><strong>Node Step</strong></p><p>选择$v_i\in V$，定义候选集为$V_i={&lt;a_i,b_i,l_i^{(k)}&gt;|1\le K\le\beta_v}$，其中$l_i^{(k)}$表示$v_i$中分数第$k$高的局部标签分数，$\beta_v$是控制候选标签数量的超参数（hyper-parameter）。通过如下公式更新束集（beam set）：<br>$$<br>B\leftarrow{G+v|(G,v)\in B\times V_i}<br>$$</p></li><li><p><strong>Edge Step</strong></p><p>迭代地选择一个$i$之前的结点$v_j\in V,j&lt;i$，同时在$v_j$和$v_i$之间添加可能的边。如果$v_i$和$v_j$都是触发器（trigger）则跳过$v_j$。每一次迭代中，我们构造一个候选边集$E_{ij}={&lt;j,i,l_{ij}^{(k)}&gt;|1\le k\le \beta_e}$，其中$l_{ij}^{(k)}$是$e_{ij}$中分数第$k$高的标签，$\beta_e$是候选标签数量的阈值。之后，通过如下函数更新束集：<br>$$<br>B\leftarrow {G+e|(G,e)\in B\times E_{ij}}<br>$$<br>在每次edge step的最后，如果$|B|$超过束的宽度$\theta$，我们对候选对象按全局分数从高到低进行排序，只保留分数最高的$\theta$个。</p></li></ol><p>最后一步之后，返回全局分数最高的图，作为输入语句中提取的信息网络。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
            <tag> 论文笔记 </tag>
            
            <tag> ACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化（规划）问题</title>
      <link href="/2020/08/08/shu-xue-gui-hua/"/>
      <url>/2020/08/08/shu-xue-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p>在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li><strong>比例性</strong></li><li><strong>可加性</strong></li><li><strong>连续性</strong></li></ul><p>比例性和可加性保证目标函数和约束条件对于决策变量的线性性，连续性则允许得到决策变量的实数最优解。</p><h2 id="标准模型"><a href="#标准模型" class="headerlink" title="标准模型"></a>标准模型</h2><p>$$<br>\max\quad z=\sum_{j=1}^n{c_jx_j}\<br>s.t.\quad \begin{cases}<br>\sum_{j=1}^{n}{a_{ij}x_j}=b_i\quad i=1,2,…,m\<br>x_j\ge0\quad j=1,2,…,n<br>\end{cases}<br>$$</p><h2 id="scipy库——scipy-optimize-linprog"><a href="#scipy库——scipy-optimize-linprog" class="headerlink" title="scipy库——scipy.optimize.linprog"></a>scipy库——scipy.optimize.linprog</h2><h3 id="模型形式"><a href="#模型形式" class="headerlink" title="模型形式"></a>模型形式</h3><p>$$<br>\min_{x}{c^{T}x}\<br>s.t.\begin{cases}<br>A_{ub}x\le b_{ub},\<br>A_{eq}x=b_{eq}\<br>l\le x\le u,<br>\end{cases}<br>$$</p><ul><li>x：决策变量的向量</li><li>$c,b_{ub},b_{eq},l,u$：向量</li><li>$A_{ub},A_{eq}$：矩阵</li></ul><p>##　使用</p><pre class="line-numbers language-python"><code class="language-python">scipy<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>linprog<span class="token punctuation">(</span>    c<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 一维向量，要最小化的线性目标函数的系数</span>    A_ub<span class="token operator">=</span>None<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 不等式约束矩阵，每一行指定x上线性不等式约束的系数</span>    b_ub<span class="token operator">=</span>None<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 不等式约束向量，每一个元素代表一个对应的值的上限</span>    A_eq<span class="token operator">=</span>None<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 等式约束矩阵，每一行指定x上线性等式约束的系数</span>    b_eq<span class="token operator">=</span>None<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 等式约束向量，A_eq@x的每个元素必须等于b_eq的相应元素</span>    bounds<span class="token operator">=</span>None<span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># sequence，x中每个元素的（min，max）对序列，定义该决策变量的最小值和最大值。</span>                <span class="token comment" spellcheck="true"># 默认情况下，边界是（0，None）（所有决策变量都是非负的）。                </span>    method<span class="token operator">=</span><span class="token string">'interior-point'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 用于解决标准格式问题的算法，</span>                              <span class="token comment" spellcheck="true"># &amp;#123;‘interior-point’, ‘revised simplex’, ‘simplex’&amp;#125;</span>    callback<span class="token operator">=</span>None<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 如果提供了回调函数，则每次算法迭代将至少调用一次回调函数 </span>    options<span class="token operator">=</span>None<span class="token punctuation">,</span>         x0<span class="token operator">=</span>None     <span class="token comment" spellcheck="true"># 决策变量的猜测值，通过优化算法对其进行优化。</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># method='revised simplex'，并且只有当x0代表一个基本的可行解时才能使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><ul><li><p><strong>interior-point method——内点法</strong></p><p>从初始内点出发，沿着最速下降方向，通过可行域内部直接达到最优解，由于是在可行域内部寻优，故对于大规模线性规划问题，当约束条件和变量数目增加时，内点算法的迭代次数变化较少，收敛性和计算速度均优于单纯形法。</p></li><li><p><strong>revised simplex method——修正单纯形法</strong></p><p>基本步骤和单纯形法大致相同，主要区别是在逐次迭代中不再以高斯消去法为基础，而是由旧基阵的逆去直接计算新基阵的逆，再由此确定检验数。这样做可以减少迭代中的累积误差，提高计算精度，同时也减少了在计算机上的存储量。</p></li><li><p><strong>simplex method——单纯形法</strong></p><p>先找出可行域的一个顶点，据一定规则判断其是否最优；若否，则转换到与之相邻的另一顶点，并使目标函数值更优；如此下去，直到找到某最优解为止。寻优步数随着决策变量的增加呈指数增长（最差情况下，具有指数复杂度）。</p></li></ul><h3 id="返回值——res"><a href="#返回值——res" class="headerlink" title="返回值——res"></a>返回值——res</h3><p>A <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult"><code>scipy.optimize.OptimizeResult</code></a> consisting of the fields:</p><blockquote><p><strong>x： 1-D array</strong></p><p>在满足约束条件下使目标函数<strong>最小化</strong>的决策变量的值。</p><p><strong>fun： float</strong></p><p>目标函数的最优值。</p><p><strong>slack： 1-D array</strong></p><p>松弛变量（&gt;0）, <code>b_ub - A_ub @ x</code>.</p><p><strong>con1-D： array</strong></p><p>等式约束的（=0）残差, <code>b_eq - A_eq @ x</code>.</p><p><strong>success： bool</strong></p><p><code>True</code> when the algorithm succeeds in finding an optimal solution.</p><p><strong>status： int</strong></p><p>An integer representing the exit status of the algorithm.</p><p><code>0</code> : 优化成功终止.</p><p><code>1</code> : 达到迭代上限.</p><p><code>2</code> : 问题似乎不可行.</p><p><code>3</code> : 问题似乎没有边界.</p><p><code>4</code> : 遇到数字困难.</p><p><strong>nit： int</strong></p><p>在所有阶段中执行的迭代总数。</p><p><strong>message： str</strong></p><p>算法退出状态的字符串</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>考虑一个简单的线性规划问题：<br>$$<br>\begin{split}\max_{x_1, x_2, x_3, x_4} \ &amp; 29x_1 + 45x_2 \ \mbox{such that} \ &amp; x_1 -x_2 -3x_3 \leq 5\ &amp; 2x_1 -3x_2 -7x_3 + 3x_4 \geq 10\ &amp; 2x_1 + 8x_2 + x_3 = 60\ &amp; 4x_1 + 4x_2 + x_4 = 60\ &amp; 0 \leq x_0\ &amp; 0 \leq x_1 \leq 5\ &amp; x_2 \leq 0.5\ &amp; -3 \leq x_3\\end{split}<br>$$<br>首先，让我们考虑目标函数。我们希望最大化目标函数，但<code>linprog</code>只能接受最小化问题。通过将最大化转换为很容易解决 29x1+45x2 最小化$ −29x_1−45x_2$，$x_3,x_4$在目标函数中未显示。这意味着$x_3,x_4$权重为零。因此，目标函数可以转换为：<br>$$<br>\min_{x_1,x_2,x_3,x_4}{-29x_1-45x_2+0x_3+0x_4}<br>$$<br>如果我们定义决策变量的向量 $x=[x_1,x_2,x_3,x_4]^T$，目标权重向量 c在这个问题应该是：<br>$$<br>c=[-29,-45,0,0]^T<br>$$<br>接下来，让我们考虑两个不平等约束。第一个是“小于”不等式，因此它已经处于被<code>linprog</code>接受的形式。第二个是“大于”不等式，因此我们需要将双方乘以−1将其转化为“小于”不平等，同时明确显示零系数，得到：<br>$$<br>x_1-x_2-3x_3+0x_4\le 5\<br>-2x_1+3x_2+7x_3-3x_4\le-10<br>$$<br>将以上方程式转换为矩阵形式：<br>$$<br>A_{ub}x\le b_{ub}\<br>A_{ub}=\begin{bmatrix}<br>1&amp;-1&amp;-3&amp;0\<br>-2&amp;3&amp;7&amp;-3<br>\end{bmatrix}\<br>b_{ub}=\begin{bmatrix}<br>5\-10<br>\end{bmatrix}<br>$$<br>接下来考虑两个相等约束，同时明确显示零权重，得到：<br>$$<br>2x_1+8x_2+1x_3+0x_4=60\<br>4x_1+4x_2+0x_3+1x_4=60<br>$$<br>转换为矩阵形式，得到：<br>$$<br>A_{eq}x=b_{eq}\<br>A_{eq}=\begin{bmatrix}<br>2&amp;8&amp;1&amp;0\<br>4&amp;4&amp;0&amp;1<br>\end{bmatrix}\<br>b_{eq}=\begin{bmatrix}<br>60\60<br>\end{bmatrix}<br>$$<br>最后，让我们考虑对各个决策变量的单独不等式约束，这些约束称为“框约束”或“简单边界”。可以使用的bounds参数应用这些约束。bounds的默认值为<code>(0, None)</code>，这意味着每个决策变量的下限为0，而每个决策变量的上限为无穷大：所有决策变量均为非负数。我们的界限是不同的，因此我们需要将每个决策变量的下限和上限指定为元组，并将这些元组分组到一个列表中。</p><p><strong>实现代码：</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> linprogc <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">29.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">45.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>A_ub <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">7.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b_ub <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>A_eq <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b_eq <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">60.0</span><span class="token punctuation">,</span> <span class="token number">60.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x0_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>x1_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span>x2_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>np<span class="token punctuation">.</span>inf<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># +/- np.inf can be used instead of None</span>x3_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>bounds <span class="token operator">=</span> <span class="token punctuation">[</span>x0_bounds<span class="token punctuation">,</span> x1_bounds<span class="token punctuation">,</span> x2_bounds<span class="token punctuation">,</span> x3_bounds<span class="token punctuation">]</span>result <span class="token operator">=</span> linprog<span class="token punctuation">(</span>c<span class="token punctuation">,</span> A_ub<span class="token operator">=</span>A_ub<span class="token punctuation">,</span> b_ub<span class="token operator">=</span>b_ub<span class="token punctuation">,</span> A_eq<span class="token operator">=</span>A_eq<span class="token punctuation">,</span> b_eq<span class="token operator">=</span>b_eq<span class="token punctuation">,</span> bounds<span class="token operator">=</span>bounds<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果：</strong></p><pre class="line-numbers language-python"><code class="language-python">    con<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">15.5361242</span> <span class="token punctuation">,</span> <span class="token number">16.61288005</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span>    fun<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">370.2321976308326</span>  <span class="token comment" spellcheck="true"># may vary </span>message<span class="token punctuation">:</span> <span class="token string">'The algorithm terminated successfully and determined that the problem is infeasible.'</span>    nit<span class="token punctuation">:</span> <span class="token number">6</span>  <span class="token comment" spellcheck="true"># may vary</span>  slack<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">0.79314989</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.76308532</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span> status<span class="token punctuation">:</span> <span class="token number">2</span> success<span class="token punctuation">:</span> <span class="token boolean">False</span>      x<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">6.60059391</span><span class="token punctuation">,</span>  <span class="token number">3.97366609</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.52664076</span><span class="token punctuation">,</span>  <span class="token number">1.09007993</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果表明我们的问题是<strong>不可行</strong>的，这意味着没有满足所有约束的解向量。这并不一定意味着我们做错了任何事。有些问题确实是不可行的。但是，假设我们要决定对$x_1$太紧了，尝试松动到 $0≤x_1≤6$。调整我们的代码以反映更改并再次执行之后：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> linprogc <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">29.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">45.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>A_ub <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">7.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b_ub <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>A_eq <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b_eq <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">60.0</span><span class="token punctuation">,</span> <span class="token number">60.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x0_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>x1_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 修改</span>x2_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span>np<span class="token punctuation">.</span>inf<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># +/- np.inf can be used instead of None</span>x3_bounds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>bounds <span class="token operator">=</span> <span class="token punctuation">[</span>x0_bounds<span class="token punctuation">,</span> x1_bounds<span class="token punctuation">,</span> x2_bounds<span class="token punctuation">,</span> x3_bounds<span class="token punctuation">]</span>result <span class="token operator">=</span> linprog<span class="token punctuation">(</span>c<span class="token punctuation">,</span> A_ub<span class="token operator">=</span>A_ub<span class="token punctuation">,</span> b_ub<span class="token operator">=</span>b_ub<span class="token punctuation">,</span> A_eq<span class="token operator">=</span>A_eq<span class="token punctuation">,</span> b_eq<span class="token operator">=</span>b_eq<span class="token punctuation">,</span> bounds<span class="token operator">=</span>bounds<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到结果：</p><pre class="line-numbers language-python"><code class="language-python">    con<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">9.78840831e-09</span><span class="token punctuation">,</span> <span class="token number">1.04662945e-08</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span>    fun<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">505.97435889013434</span>  <span class="token comment" spellcheck="true"># may vary</span>message<span class="token punctuation">:</span> <span class="token string">'Optimization terminated successfully.'</span>    nit<span class="token punctuation">:</span> <span class="token number">4</span>  <span class="token comment" spellcheck="true"># may vary</span>  slack<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">6.52747190e-10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.26730279e-09</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span> status<span class="token punctuation">:</span> <span class="token number">0</span>success<span class="token punctuation">:</span> <span class="token boolean">True</span>      x<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">9.41025641</span><span class="token punctuation">,</span>  <span class="token number">5.17948718</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.25641026</span><span class="token punctuation">,</span>  <span class="token number">1.64102564</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以检查目标值：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>result<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c @ x<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">505.97435889013434</span>  <span class="token comment" spellcheck="true"># may vary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们还可以检查所有约束是否都在合理的公差范围内：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b_ub <span class="token operator">-</span> <span class="token punctuation">(</span>A_ub @ x<span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># this is equivalent to result.slack</span><span class="token punctuation">[</span> <span class="token number">6.52747190e-10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.26730279e-09</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># may vary</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b_eq <span class="token operator">-</span> <span class="token punctuation">(</span>A_eq @ x<span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># this is equivalent to result.con</span><span class="token punctuation">[</span> <span class="token number">9.78840831e-09</span><span class="token punctuation">,</span> <span class="token number">1.04662945e-08</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># may vary</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token operator">&lt;=</span> result<span class="token punctuation">.</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> result<span class="token punctuation">.</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">6.0</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span> <span class="token operator">&lt;=</span> result<span class="token punctuation">.</span>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们需要更高的精度（通常以速度为代价），则可以使用以下方法求解：<code>revised simplex</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    con<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.00000000e+00</span><span class="token punctuation">,</span> <span class="token number">7.10542736e-15</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span>    fun<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">505.97435897435895</span>    <span class="token comment" spellcheck="true"># may vary</span>message<span class="token punctuation">:</span> <span class="token string">'Optimization terminated successfully.'</span>    nit<span class="token punctuation">:</span> <span class="token number">5</span>  <span class="token comment" spellcheck="true"># may vary</span>  slack<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.77635684e-15</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.55271368e-15</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span> status<span class="token punctuation">:</span> <span class="token number">0</span>success<span class="token punctuation">:</span> <span class="token boolean">True</span>      x<span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">9.41025641</span><span class="token punctuation">,</span>  <span class="token number">5.17948718</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.25641026</span><span class="token punctuation">,</span>  <span class="token number">1.64102564</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># may vary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h1><h2 id="scipy-optimize-minimize"><a href="#scipy-optimize-minimize" class="headerlink" title="scipy.optimize.minimize"></a>scipy.optimize.minimize</h2><p>用于无约束和有约束的最小化算法</p><pre class="line-numbers language-python"><code class="language-python">scipy<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>    fun<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 需要最小化的目标函数</span>    x0<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 初步猜测</span>    args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     method<span class="token operator">=</span>None<span class="token punctuation">,</span>     jac<span class="token operator">=</span>None<span class="token punctuation">,</span>     hess<span class="token operator">=</span>None<span class="token punctuation">,</span>     hessp<span class="token operator">=</span>None<span class="token punctuation">,</span>     bounds<span class="token operator">=</span>None<span class="token punctuation">,</span>     constraints<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     tol<span class="token operator">=</span>None<span class="token punctuation">,</span>     callback<span class="token operator">=</span>None<span class="token punctuation">,</span>     options<span class="token operator">=</span>None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>Parameters:</strong></p><ul><li><p><strong>fun</strong>    <em>callable</em></p><p> 需要最小化的目标函数<code>fun(x, *args) -&gt; float</code></p><ul><li><code>x</code>是形状为（n，）的一维数组</li><li><code>args</code> 是完全指定函数所需的固定参数的元组</li></ul></li><li><p><strong>x0</strong>    <em>ndarray, shape (n,)</em></p><p>初步猜测，大小为（n，）的实数元素的数组</p></li><li><p><strong>args    可选</strong>    <em>tuple</em></p><p>额外的参数传递给目标函数及其派生类（<em>fun</em>，<em>jac</em>和<em>hess</em>函数）</p></li><li><p><strong>method    可选</strong>    <em>str or callable</em></p><p>求解器类型。具体参照之后有约束和无约束情况。</p><p>如果没有给出，选择为之一<code>BFGS</code>，<code>L-BFGS-B</code>，<code>SLSQP</code>，取决于如果问题有约束或边界。</p></li><li><p><strong>jac    可选</strong>    <em>{callable, ‘2-point’, ‘3-point’, ‘cs’, bool}</em></p><p>梯度矢量的计算方法。仅适用于CG，BFGS，Newton-CG，L-BFGS-B，TNC，SLSQP，dogleg，trust-ncg，trust-krylov，trust-exact和trust-constr。</p><p>如果它是可调用的，则应该是一个返回梯度向量的函数：<code>jac(x, *args) -&gt; array_like, shape (n,)</code></p></li><li><p><strong>hess    可选</strong>    <em>{callable, ‘2-point’, ‘3-point’, ‘cs’, HessianUpdateStrategy}</em></p><p>计算黑塞矩阵的方法。仅适用于Newton-CG，dogleg，trust-ncg，trust-krylov，trust-exact和trust-constr。</p><p>如果可以调用，则应返回黑塞矩阵：<code>hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)</code></p></li><li><p><strong>hessp    可选</strong>    <em>callable</em></p><p>目标函数的黑塞矩阵乘以任意向量p。仅适用于Newton-CG，trust-ncg，trust-krylov，trust-constr。</p><p><em>hessp</em>或<em>hess只需要给予一个。如果提供了</em>hess<em>，那么</em>hessp*将被忽略。 </p><p><em>hessp</em>必须计算黑塞矩阵乘以一个向量：<code>hessp(x, p, *args) -&gt; ndarray shape (n,)</code></p></li><li><p><strong>bounds    可选</strong>    <em>sequence or <code>Bounds</code></em></p><p>L-BFGS-B，TNC，SLSQP，Powell和trust-constr方法的变量界限。有两种方法可以指定范围：</p><ul><li><code> Bounds class</code>的一个实例</li><li><em>x中</em>每个元素的<code>(min, max)</code>序列，<code>None</code>用于指定无边界。</li></ul></li><li><p><strong>constrains    可选</strong>     <em>{Constraint, dict} or List of {Constraint, dict}</em></p><p>约束定义（仅适用于COBYLA，SLSQP和trust-constr）。“ trust-constr”的约束定义为单个对象或指定优化问题约束的对象列表。可用的约束是：</p><ul><li><code>LinearConstraint</code>，线性约束</li><li><code>NonlinearConstraint</code>，非线性约束</li></ul></li><li><p><strong>tol    可选</strong>    <em>float</em></p><p>终止公差。要进行详细控制，请使用特定于求解器的选项。</p></li><li><p><strong>options    可选</strong>    <em>dict</em></p><p>求解器选项字典。所有方法都接受以下通用选项：</p><ul><li><code>maxiter</code>：要执行的最大迭代次数。根据方法的不同，每个迭代可能会使用多个函数评估。</li><li><code>disp</code>：设置为<code>True</code>以打印收敛消息。</li></ul></li><li><p><strong>callback    可选</strong>    <em>callable</em></p><p>在每次迭代后调用。</p></li></ul><p><strong>Return:</strong></p><ul><li><strong>res</strong>    <em>OptimizeResult</em></li></ul></blockquote><h2 id="无约束"><a href="#无约束" class="headerlink" title="无约束"></a>无约束</h2><p>无约束优化问题形式如下：<br>$$<br>\text{minimize}\quad f(\bold{x})\<br>\text{subject to}\quad \bold{x}\in\Omega<br>$$</p><ul><li><p><strong>Nelder-Mead 单纯形法（<code>method='Nelder-Mead'</code>）</strong></p><p>单纯形算法可能是最小化行为良好的函数的最简单方法。它仅需要功能评估，对于简单的最小化问题是一个不错的选择。但是，由于它不使用任何梯度评估，因此可能需要更长的时间才能找到最小值。</p></li><li><p><strong>鲍威尔算法（<code>method='Powell'</code>）</strong></p><p>利用共轭方向可以加快收敛速度的性质形成的一种搜索方法。该方法不需要对目标函数进行求导，当目标函数的导数不连续的时候也能应用，因此，鲍威尔算法是一种十分有效的直接搜索法。</p><p>Powell法可用于求解一般无约束优化问题，对于维数n&lt;20的目标函数求优化问题，此法可获得较满意的结果。</p></li><li><p><strong>BFGS算法（<code>method='BFGS'</code>）</strong></p><p>为了更快地收敛到解，该例程使用目标函数的梯度。如果用户未给出梯度，则使用一阶差进行估算。BFGS方法通常需要比单纯形算法更少的函数调用，即使必须估计梯度也是如此。</p></li><li><p><strong>共轭梯度算法（<code>method='CG'</code>）</strong></p><p>共轭梯度法是一个典型的共轭方向法，它的每一个搜索方向是互相共轭的，而这些搜索方向d仅仅是负梯度方向与上一次迭代的搜索方向的组合，因此，存储量少，计算方便。</p></li><li><p><strong>牛顿共轭梯度算法（<code>method='Newton-CG'</code>）</strong></p><p>牛顿共轭梯度算法是牛顿方法的一种改进方法，它使用共轭梯度算法来（近似）反转局部黑塞矩阵。</p></li><li><p><strong>L-BFGS-B算法（<code>method='L-BFGS-B'</code>）</strong></p><p>L-BFGS-B是用于受限约束优化的有限内存拟牛顿算法，适用于任何类型的带有线搜索的非线性（或线性）问题。另外，对于L-BFGS-B和共轭梯度求解器，收敛所需的迭代次数几乎相同。</p></li><li><p><strong>牛顿截断法（<code>method='TNC'</code>）</strong></p><p>阶段牛顿法旨在优化具有大量自变量的非线性函数。</p></li><li><p><strong>信任区域牛顿共轭梯度算法（<code>method='trust-ncg'</code>）</strong></p><p>该方法是线搜索方法：它找到使函数的二次逼近最小的搜索方向，然后使用线搜索算法在该方向上找到（几乎）最佳步长。</p></li><li><p><strong>信任区域截断的广义Lanczos /共轭梯度算法（<code>method='trust-krylov'</code>）</strong></p><p>该方法是一种适用于大规模问题的方法，因为它仅通过矩阵向量积将hessian用作线性算子。</p></li></ul><h2 id="有约束"><a href="#有约束" class="headerlink" title="有约束"></a>有约束</h2><p>有约束优化问题标准化形式如下：<br>$$<br>\begin{align}<br>\text{minimize}\quad &amp;f(\bold{x})\<br>\text{subject to}\quad &amp;\bold{h(x)=0}\<br>&amp;\bold{g(x)\le 0}<br>\end{align}<br>$$</p><ul><li><p><strong>线性逼近约束优化（<code>method='COBYLA'</code>）</strong></p><p>通过迭代逼近实际约束优化问题和线性规划问题来工作。在迭代过程中，解决了近似线性规划问题，以获得最佳解的候选者。使用原始目标和约束函数评估候选解决方案，从而在优化空间中产生一个新的数据点。此信息用于改进算法的下一次迭代所用的近似线性规划问题。当解决方案无法再改进时，步长将减小，从而完善了搜索范围。当步长变得足够小时，算法结束。</p></li><li><p><strong>递推最小二乘算法（<code>method='SLSQP'</code>）</strong></p><p>SLSQP方法用于目标函数和约束两次连续可微的数学问题。SQP方法解决了一系列优化子问题，每个子问题都会根据约束的线性化来优化目标的二次模型。</p></li><li><p><strong>信任区域算法（<code>method='trust-constr'</code>）</strong></p><p>在数学优化中，信任区域算法是使用模型函数（通常是二次函数）近似的目标函数区域的子集。如果在信任区域内找到了目标函数的适当模型，则该区域将扩展；否则，该区域将被扩展。相反，如果近似值不佳，则该区域将缩小。通过比较模型近似的预期改进与目标函数中观察到的实际改进的比率来评估拟合。</p></li><li><p><strong>狗腿信任区域算法（<code>method='dogleg'</code>）</strong></p><p>对朴素信任区域算法进行改进。</p></li><li><p><strong>牛顿共轭梯度信任区算法（<code>method='trust-ncg'</code>）</strong></p></li><li><p><strong>近似精确信任区域算法（<code>method='trust-exact'</code>）</strong></p></li><li><p><strong>改进近似精确信任区域算法（<code>method='trust-krylov'</code>）</strong></p><p>使用仅需要矩阵向量乘积与黑塞矩阵的近似精确信任区域算法。</p></li></ul><h1 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h1><p>多目标优化问题可表示为：<br>$$<br>\text{minimize}\quad \bold{f(x)}=\begin{bmatrix}<br>f_1(x_1,x_2,…,x_n)\<br>f_2(x_1,x_2,…,x_n)\<br>…\<br>f_l(x_1,x_2,…,x_n)<br>\end{bmatrix}\<br>\text{subject to}\quad x\in\Omega<br>$$<br>通常情况下，求解多目标优化问题需要在多个目标之间寻找合适的折中。简而言之，在多目标优化问题中，综合考虑所有的目标函数，对于某个解，在可行集内没有其他解能够对目标进行改进，那么这个解就是最优解。</p><p>习惯将多目标优化问题的最优解称为帕累托极小点（帕累托解）。帕累托极小点（最优解）的集合称为帕累托前沿。</p><h2 id="多目标进化算法"><a href="#多目标进化算法" class="headerlink" title="多目标进化算法"></a>多目标进化算法</h2><p>使用<code>geatpy</code>实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># MyProblem.py</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> geatpy <span class="token keyword">as</span> ea<span class="token triple-quoted-string string">"""该案例展示了一个离散决策变量的最小化目标的双目标优化问题。min f1 = -25 * (x1 - 2)**2 - (x2 - 2)**2 - (x3 - 1)**2 - (x4 - 4)**2 - (x5 - 1)**2min f2 = (x1 - 1)**2 + (x2 - 1)**2 + (x3 - 1)**2 + (x4 - 1)**2 + (x5 - 1)**2s.t.x1 + x2 >= 2x1 + x2 &lt;= 6x1 - x2 >= -2x1 - 3*x2 &lt;= 24 - (x3 - 3)**2 - x4 >= 0(x5 - 3)**2 + x4 - 4 >= 0x1,x2,x3,x4,x5 ∈ &amp;#123;0,1,2,3,4,5,6,7,8,9,10&amp;#125;"""</span><span class="token keyword">class</span> <span class="token class-name">MyProblem</span><span class="token punctuation">(</span>ea<span class="token punctuation">.</span>Problem<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 继承Problem父类</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        name <span class="token operator">=</span> <span class="token string">'MyProblem'</span> <span class="token comment" spellcheck="true"># 初始化name（函数名称，可以随意设置）</span>        Dim <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment" spellcheck="true"># 初始化Dim（决策变量维数）</span>        maxormins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> M <span class="token comment" spellcheck="true"># 初始化maxormins（目标最小最大化标记列表，1：最小化该目标；-1：最大化该目标）</span>        varTypes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> Dim <span class="token comment" spellcheck="true"># 初始化varTypes（决策变量的类型，0：实数；1：整数）</span>        lb <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> Dim <span class="token comment" spellcheck="true"># 决策变量下界</span>        ub <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">*</span> Dim <span class="token comment" spellcheck="true"># 决策变量上界</span>        lbin <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> Dim <span class="token comment" spellcheck="true"># 决策变量下边界（0表示不包含该变量的下边界，1表示包含）</span>        ubin <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> Dim <span class="token comment" spellcheck="true"># 决策变量上边界（0表示不包含该变量的上边界，1表示包含）</span>        <span class="token comment" spellcheck="true"># 调用父类构造方法完成实例化</span>        ea<span class="token punctuation">.</span>Problem<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> M<span class="token punctuation">,</span> maxormins<span class="token punctuation">,</span> Dim<span class="token punctuation">,</span> varTypes<span class="token punctuation">,</span> lb<span class="token punctuation">,</span> ub<span class="token punctuation">,</span> lbin<span class="token punctuation">,</span> ubin<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">aimFunc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pop<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 目标函数</span>        Vars <span class="token operator">=</span> pop<span class="token punctuation">.</span>Phen <span class="token comment" spellcheck="true"># 得到决策变量矩阵</span>        x1 <span class="token operator">=</span> Vars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        x2 <span class="token operator">=</span> Vars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        x3 <span class="token operator">=</span> Vars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        x4 <span class="token operator">=</span> Vars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        x5 <span class="token operator">=</span> Vars<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        f1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">25</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token punctuation">(</span>x2 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token punctuation">(</span>x3 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token punctuation">(</span>x4 <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token punctuation">(</span>x5 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span>        f2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x3 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x4 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x5 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token comment" spellcheck="true">#        # 利用罚函数法处理约束条件</span><span class="token comment" spellcheck="true">#        idx1 = np.where(x1 + x2 &lt; 2)[0]</span><span class="token comment" spellcheck="true">#        idx2 = np.where(x1 + x2 > 6)[0]</span><span class="token comment" spellcheck="true">#        idx3 = np.where(x1 - x2 &lt; -2)[0]</span><span class="token comment" spellcheck="true">#        idx4 = np.where(x1 - 3*x2 > 2)[0]</span><span class="token comment" spellcheck="true">#        idx5 = np.where(4 - (x3 - 3)**2 - x4 &lt; 0)[0]</span><span class="token comment" spellcheck="true">#        idx6 = np.where((x5 - 3)**2 + x4 - 4 &lt; 0)[0]</span><span class="token comment" spellcheck="true">#        exIdx = np.unique(np.hstack([idx1, idx2, idx3, idx4, idx5, idx6])) # 得到非可行解的下标</span><span class="token comment" spellcheck="true">#        f1[exIdx] = f1[exIdx] + np.max(f1) - np.min(f1)</span><span class="token comment" spellcheck="true">#        f2[exIdx] = f2[exIdx] + np.max(f2) - np.min(f2)</span>        <span class="token comment" spellcheck="true"># 利用可行性法则处理约束条件</span>        pop<span class="token punctuation">.</span>CV <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">-</span> x1 <span class="token operator">-</span> x2<span class="token punctuation">,</span>                            x1 <span class="token operator">+</span> x2 <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">,</span>                            <span class="token operator">-</span><span class="token number">2</span> <span class="token operator">-</span> x1 <span class="token operator">+</span> x2<span class="token punctuation">,</span>                            x1 <span class="token operator">-</span> <span class="token number">3</span><span class="token operator">*</span>x2 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span>                            <span class="token punctuation">(</span>x3 <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> x4 <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">,</span>                            <span class="token number">4</span> <span class="token operator">-</span> <span class="token punctuation">(</span>x5 <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> x4<span class="token punctuation">]</span><span class="token punctuation">)</span>        pop<span class="token punctuation">.</span>ObjV <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">[</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把求得的目标函数值赋值给种群pop的ObjV</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># main.py</span><span class="token keyword">import</span> geatpy <span class="token keyword">as</span> ea     <span class="token comment" spellcheck="true"># import geatpy</span><span class="token keyword">from</span> MyProblem <span class="token keyword">import</span> MyProblem    <span class="token comment" spellcheck="true"># 导入自定义问题接口</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""================================实例化问题对象==========================="""</span>    problem <span class="token operator">=</span> MyProblem<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 生成问题对象</span>    <span class="token triple-quoted-string string">"""==================================种群设置==============================="""</span>    Encoding <span class="token operator">=</span> <span class="token string">'BG'</span>             <span class="token comment" spellcheck="true"># 编码方式</span>    NIND <span class="token operator">=</span> <span class="token number">50</span>                   <span class="token comment" spellcheck="true"># 种群规模</span>    Field <span class="token operator">=</span> ea<span class="token punctuation">.</span>crtfld<span class="token punctuation">(</span>Encoding<span class="token punctuation">,</span> problem<span class="token punctuation">.</span>varTypes<span class="token punctuation">,</span> problem<span class="token punctuation">.</span>ranges<span class="token punctuation">,</span> problem<span class="token punctuation">.</span>borders<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建区域描述器</span>    population <span class="token operator">=</span> ea<span class="token punctuation">.</span>Population<span class="token punctuation">(</span>Encoding<span class="token punctuation">,</span> Field<span class="token punctuation">,</span> NIND<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实例化种群对象（此时种群还没被初始化，仅仅是完成种群对象的实例化）</span>    <span class="token triple-quoted-string string">"""================================算法参数设置============================="""</span>    myAlgorithm <span class="token operator">=</span> ea<span class="token punctuation">.</span>moea_NSGA2_templet<span class="token punctuation">(</span>problem<span class="token punctuation">,</span> population<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实例化一个算法模板对象</span>    myAlgorithm<span class="token punctuation">.</span>mutOper<span class="token punctuation">.</span>Pm <span class="token operator">=</span> <span class="token number">0.2</span> <span class="token comment" spellcheck="true"># 修改变异算子的变异概率</span>    myAlgorithm<span class="token punctuation">.</span>recOper<span class="token punctuation">.</span>XOVR <span class="token operator">=</span> <span class="token number">0.9</span> <span class="token comment" spellcheck="true"># 修改交叉算子的交叉概率</span>    myAlgorithm<span class="token punctuation">.</span>MAXGEN <span class="token operator">=</span> <span class="token number">200</span>    <span class="token comment" spellcheck="true"># 最大进化代数</span>    <span class="token triple-quoted-string string">"""==========================调用算法模板进行种群进化========================"""</span>    NDSet <span class="token operator">=</span> myAlgorithm<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 执行算法模板，得到帕累托最优解集NDSet</span>    NDSet<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 把结果保存到文件中</span>    <span class="token comment" spellcheck="true"># 输出</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'用时：%s 秒'</span><span class="token operator">%</span><span class="token punctuation">(</span>myAlgorithm<span class="token punctuation">.</span>passTime<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'非支配个体数：%s 个'</span><span class="token operator">%</span><span class="token punctuation">(</span>NDSet<span class="token punctuation">.</span>sizes<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'单位时间找到帕累托前沿点个数：%s 个'</span><span class="token operator">%</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>NDSet<span class="token punctuation">.</span>sizes <span class="token operator">//</span> myAlgorithm<span class="token punctuation">.</span>passTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得到输出：</p><pre class="line-numbers language-shell"><code class="language-shell">种群信息导出完毕。用时：0.15359210968017578 秒非支配个体数：50 个单位时间找到帕累托前沿点个数：325 个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>帕累托前沿分布：</p><p><img src="E:\Thor\Documents\Study\数学建模\数学规划.assets\image-20200706142245386.png" alt="image-20200706142245386"></p><p>结果保存为文件：</p><p><img src="E:\Thor\Documents\Study\数学建模\数学规划.assets\image-20200706143959892.png" alt="image-20200706143959892"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><ul><li><h4 id="给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解"><a href="#给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解" class="headerlink" title="给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解"></a>给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解</h4></li><li><h4 id="很多优化问题可分为多个子问题，子问题相互关联，子问题的解被-重复使用"><a href="#很多优化问题可分为多个子问题，子问题相互关联，子问题的解被-重复使用" class="headerlink" title="很多优化问题可分为多个子问题，子问题相互关联，子问题的解被==重复使用=="></a>很多优化问题可分为多个子问题，子问题相互关联，子问题的解被==重复使用==</h4></li></ul><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><h4 id="优化子结构"><a href="#优化子结构" class="headerlink" title="优化子结构"></a>优化子结构</h4><ul><li><strong>一个问题的优化解包含了子问题的优化解</strong></li></ul></li><li><h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><ul><li><strong>在问题的求解过程中，很多子问题的解将被多次使用</strong></li></ul></li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li><h4 id="刻画一个最优解的结构特征"><a href="#刻画一个最优解的结构特征" class="headerlink" title="刻画一个最优解的结构特征"></a>刻画一个最优解的结构特征</h4><p>寻找最优子结构，利用这种子结构从子问题的最优解构造出原问题的最优解</p></li><li><h4 id="递归定义最优解的值"><a href="#递归定义最优解的值" class="headerlink" title="递归定义最优解的值"></a>递归定义最优解的值</h4></li><li><h4 id="自底向上计算最优解的值"><a href="#自底向上计算最优解的值" class="headerlink" title="自底向上计算最优解的值"></a>自底向上计算最优解的值</h4></li><li><h4 id="根据构造最优解的信息构造优化解"><a href="#根据构造最优解的信息构造优化解" class="headerlink" title="根据构造最优解的信息构造优化解"></a>根据构造最优解的信息构造优化解</h4></li></ul><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul><li><h4 id="带备忘的自顶向下法"><a href="#带备忘的自顶向下法" class="headerlink" title="带备忘的自顶向下法"></a>带备忘的自顶向下法</h4><ul><li>递归求解</li><li>保存每个子问题的解（数组或散列表）</li></ul></li><li><h4 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h4><ul><li>恰当定义子问题的<strong>规模</strong></li><li>任何子问题的求解都只依赖于<strong>更小的</strong>子问题的解</li><li>按子问题规模<strong>由小到大进行求解</strong></li><li>第一次求解一个问题时，它的所有前提子问题都已求解完成且<strong>保存结果</strong></li></ul></li></ul><p>两种方法的算法的<strong>渐进运行时间相同</strong>，<strong>自底向上的时间复杂性</strong>函数通常具有更小的系数，某些情况下自顶向下无法真正递归考察所有可能的子问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><ul><li><p><strong>发掘最优子结构的通用模式</strong></p><ol><li>证明问题最优解的第一个组成部分是做出一个选择，做出这次选择会产生一个或多个待解的子问题</li><li>对于一个给定问题，在其可能的第一步选择中，你<strong>假定已经知道</strong>哪种选择才会得到最优解。并<strong>不关心如何得到，只是假定已经知道</strong></li><li>给定可获得最优解的选择后，你确定这次选择会产生哪些<strong>子问题</strong>，以及如何<strong>最好地刻画子问题空间</strong></li></ol></li><li><p><strong>保持子问题空间尽可能简单，只在必要时才扩展它</strong></p></li><li><p><strong>不同问题领域，最优子结构的不同</strong>：</p><ul><li>原问题的最优解中涉及多少个子问题</li><li>再确定最优解使用哪些子问题时，我们需要考虑多少种选择</li></ul></li><li><p><strong>粗略分析算法的运行时间：</strong><br>$$<br>O(m\times n)\<br>\Theta(n):子问题个数\quad\quad m:考察的选择个数<br>$$</p></li></ul><h3 id="重构最优解"><a href="#重构最优解" class="headerlink" title="重构最优解"></a>重构最优解</h3><p><strong>将每个子问题所做的选择存在一个表中</strong>：重构每次选择只需$$O(1)$$时间</p><h3 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h3><p>维护一个表记录子问题的解，保持递归算法的控制流程：</p><ul><li>每个表项的初值设为一个特殊值，表示尚未填入子问题的解</li><li>当递归调用过程中第一次遇到子问题时，计算其解，并存入对应表项</li><li>每次遇到同一个子问题，查表返回解</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><strong>通常情况</strong>：每个子问题必须至少求解一次<ul><li>自底向上动态规划算法比自顶向下备忘算法快（都是$$O(n^3)$$，相差常量系数）</li><li>自底向上算法没有递归调用的开销，表的维护开销更小</li></ul></li><li><strong>某些问题：</strong>可利用表的访问模式进一步降低时空代价</li><li><strong>某些子问题完全不必求解：</strong>备忘方法更有优势（只求解必要子问题）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sympy的基本使用</title>
      <link href="/2020/08/08/sympy/"/>
      <url>/2020/08/08/sympy/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sympy <span class="token keyword">import</span> <span class="token operator">*</span>init_printing<span class="token punctuation">(</span>use_unicode<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://docs.sympy.org/latest/tutorial/index.html"><code>Sympy</code></a>是一个用于符号计算的python库，可以完成多项式求值、求极限、解方程、求积分、微分方程等符号计算问题，介绍一些常用功能。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h2><pre class="line-numbers language-python"><code class="language-python">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token operator">=</span> symbols<span class="token punctuation">(</span><span class="token string">"x y z"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 多个变量</span>t <span class="token operator">=</span> Symbol<span class="token punctuation">(</span><span class="token string">'t'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 单个变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><h3 id="导数diff"><a href="#导数diff" class="headerlink" title="导数diff"></a>导数<code>diff</code></h3><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> diff<span class="token punctuation">(</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 高阶导数两种写法</span>In<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> diff<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">24</span>⋅xIn<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> diff<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">24</span>⋅x<span class="token comment" spellcheck="true"># 偏导数</span>In<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span>     expr <span class="token operator">=</span> exp<span class="token punctuation">(</span>x<span class="token operator">*</span>y<span class="token operator">*</span>z<span class="token punctuation">)</span>         diff<span class="token punctuation">(</span>expr<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token number">3</span>  <span class="token number">2</span> ⎛ <span class="token number">3</span>  <span class="token number">3</span>  <span class="token number">3</span>       <span class="token number">2</span>  <span class="token number">2</span>  <span class="token number">2</span>                ⎞  x⋅y⋅zx ⋅y ⋅⎝x ⋅y ⋅z  <span class="token operator">+</span> <span class="token number">14</span>⋅x ⋅y ⋅z  <span class="token operator">+</span> <span class="token number">52</span>⋅x⋅y⋅z <span class="token operator">+</span> <span class="token number">48</span>⎠⋅ℯ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="积分intergrate"><a href="#积分intergrate" class="headerlink" title="积分intergrate"></a>积分<code>intergrate</code></h3><p><code>intergrate(integration_variable, lower_limit, upper_limit)</code></p><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> integrate<span class="token punctuation">(</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">-</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>In<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> integrate<span class="token punctuation">(</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 多重积分</span>In<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> integrate<span class="token punctuation">(</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span>y<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token operator">-</span>oo<span class="token punctuation">,</span>oo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token operator">-</span>oo<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">:</span> π<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="极限limit"><a href="#极限limit" class="headerlink" title="极限limit"></a>极限<code>limit</code></h3><p><code>limit(f(x), x, x0)</code></p><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> limit<span class="token punctuation">(</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">/</span>x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 单侧极限</span>In<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> limit<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span>x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ∞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="等式Eq"><a href="#等式Eq" class="headerlink" title="等式Eq"></a>等式<code>Eq</code></h3><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Eq<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-方程"><a href="#3-方程" class="headerlink" title="3. 方程"></a>3. 方程</h2><h3 id="代数方程solveset"><a href="#代数方程solveset" class="headerlink" title="代数方程solveset"></a>代数方程<code>solveset</code></h3><p><code>solveset(f, symbol=None, domain=S.Complexes)</code></p><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> solveset<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;0, 1&amp;#125;</span>In<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> solveset<span class="token punctuation">(</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> ∅<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性方程组linsolve"><a href="#线性方程组linsolve" class="headerlink" title="线性方程组linsolve"></a>线性方程组<code>linsolve</code></h3><p><code>linsolve(system, *symbols)</code></p><pre class="line-numbers language-python"><code class="language-python">In<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> linsolve<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">+</span>y<span class="token operator">+</span>z<span class="token number">-1</span><span class="token punctuation">,</span>x<span class="token operator">+</span>y<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>z<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(-y - 1, y, 2)&amp;#125;</span>In<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span>linsolve<span class="token punctuation">(</span>Matrix<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(-y - 1, y, 2)&amp;#125;</span>In<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> M <span class="token operator">=</span> Matrix<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        system <span class="token operator">=</span> A<span class="token punctuation">,</span> b <span class="token operator">=</span> M<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> M<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        linsolve<span class="token punctuation">(</span>system<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(-y - 1, y, 2)&amp;#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非线性方程组nonlinsolve"><a href="#非线性方程组nonlinsolve" class="headerlink" title="非线性方程组nonlinsolve"></a>非线性方程组<code>nonlinsolve</code></h3><p><code>nonlinsolve(system, *symbols)</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 仅有实数解</span>In<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> nonlinsolve<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">*</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(2, 1/2)&amp;#125;</span><span class="token comment" spellcheck="true"># 仅有复数解</span>In<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> nonlinsolve<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(-ⅈ, -ⅈ), (-ⅈ, ⅈ), (ⅈ, -ⅈ), (ⅈ, ⅈ)&amp;#125;</span><span class="token comment" spellcheck="true"># 同时存在实数解和复数解</span>In<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> nonlinsolve<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>y<span class="token operator">**</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> x<span class="token operator">*</span>y<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(-2, -1), (2, 1), (-√2⋅ⅈ, √2⋅ⅈ), (√2⋅ⅈ, -√2⋅ⅈ)&amp;#125;</span><span class="token comment" spellcheck="true"># 无数值解</span>In<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> nonlinsolve<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">*</span>y<span class="token punctuation">,</span> x<span class="token operator">*</span>y<span class="token operator">-</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;(0, y)&amp;#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解的顺序与给定符号的顺序相对应.</p><h3 id="微分方程dsolve"><a href="#微分方程dsolve" class="headerlink" title="微分方程dsolve"></a>微分方程<code>dsolve</code></h3><p><code>dsolve(eq, func=None, hint="default", simplify=True, ics= None, xi=None, eta=None, x0=0, n=6, **kwargs)</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 首先需要创建新的未定义函数</span>In<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f<span class="token punctuation">,</span> g <span class="token operator">=</span> symbols<span class="token punctuation">(</span><span class="token string">'f g'</span><span class="token punctuation">,</span> cls<span class="token operator">=</span>Function<span class="token punctuation">)</span>        f<span class="token punctuation">(</span>x<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">:</span> f<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义方程</span>In<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">:</span>diffeq <span class="token operator">=</span> Eq<span class="token punctuation">(</span>x<span class="token punctuation">.</span>diff<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token operator">*</span>f<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>diff<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> f<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">:</span>          d                f<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span>⋅──<span class="token punctuation">(</span>f<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span>         dx               In<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dsolve<span class="token punctuation">(</span>diffeq<span class="token punctuation">,</span> f<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        ⎛      <span class="token operator">-</span>x              <span class="token operator">-</span>x        ⎞          ⎜      ───             ───       ⎟  x       ⎜       <span class="token number">2</span>               <span class="token number">2</span>        ⎟  ─       ⎜     ℯ   ⋅sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token number">2</span>⋅ℯ   ⋅cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>⎟  <span class="token number">2</span>f<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> ⎜C₁ <span class="token operator">+</span> ─────────── <span class="token operator">+</span> ─────────────⎟⋅ℯ        ⎝          <span class="token number">5</span>              <span class="token number">5</span>      ⎠ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论</title>
      <link href="/2020/06/01/ji-suan-ji-xi-tong-gai-lun/"/>
      <url>/2020/06/01/ji-suan-ji-xi-tong-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h1><h2 id="一、计算机软硬件概念"><a href="#一、计算机软硬件概念" class="headerlink" title="一、计算机软硬件概念"></a>一、计算机软硬件概念</h2><h3 id="1-计算机系统"><a href="#1-计算机系统" class="headerlink" title="1.计算机系统"></a>1.计算机系统</h3><p>计算机系统由<strong>硬件</strong>和<strong>软件</strong>两大部分组成。</p><ul><li>硬件：计算机实体<ul><li>主机</li><li>外设</li><li>……</li></ul></li><li>软件：由具有各类特殊功能的信息（程序）组成<ul><li>系统软件：用来管理整个计算机系统<ul><li>语言处理程序</li><li>操作系统</li><li>服务性程序</li><li>数据库管理系统</li><li>网络软件</li><li>……</li></ul></li><li>应用软件：按任务需要编制成的各种程序</li></ul></li></ul><h2 id="二、计算机系统的层次结构"><a href="#二、计算机系统的层次结构" class="headerlink" title="二、计算机系统的层次结构"></a>二、计算机系统的层次结构</h2><p>现代计算机解题过程：由用户用高级语言编写程序（源程序），将程序与数据一起送入计算机内，再由计算机将其翻译成机器能识别的机器语言程序（目标程序），机器自动运行该机器语言程序，并将结果输出。</p><img src="http://note.lizhihao999.cn/notes/20200829182043.png" alt="" style="zoom: 50%;"><img src="http://note.lizhihao999.cn/notes/20200829182016.png" alt="多级层次结构的计算机系统" style="zoom:50%;"><h2 id="三、计算机体系结构和计算机组成"><a href="#三、计算机体系结构和计算机组成" class="headerlink" title="三、计算机体系结构和计算机组成"></a>三、计算机体系结构和计算机组成</h2><h3 id="1-计算机体系结构"><a href="#1-计算机体系结构" class="headerlink" title="1. 计算机体系结构"></a>1. 计算机体系结构</h3><p><strong>计算机系统的属性，概念性的结构与功能特性</strong>$\to$<strong>可见的</strong>，比如：有无乘法指令</p><ul><li>指令系统</li><li>数据类型</li><li>寻址技术</li><li>I/O机理</li></ul><h3 id="2-计算机组成"><a href="#2-计算机组成" class="headerlink" title="2.计算机组成"></a>2.计算机组成</h3><p><strong>实现计算机体系结构所体现的属性</strong>，比如：如何实现乘法指令</p><ul><li>具体指令的实现</li></ul><h1 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h1><h2 id="一、冯·诺依曼计算机的特点"><a href="#一、冯·诺依曼计算机的特点" class="headerlink" title="一、冯·诺依曼计算机的特点"></a>一、冯·诺依曼计算机的特点</h2><ol><li><p>计算机由<strong>五大部件</strong>组成</p><ul><li><p><strong>运算器</strong>:<strong>算术运算</strong>+<strong>逻辑运算</strong></p></li><li><p>控制器:指挥控制程序运行</p></li><li><p>存储器:存放<strong>数据</strong>和<strong>程序</strong></p></li><li><p>输入设备:将信息转换成机器能识别的信息</p></li><li><p>输出设备:将结果转化为人们熟悉的形式</p></li></ul></li><li><p><strong>指令</strong>和<strong>数据</strong>以同等地位存于<strong>存储器,**可按</strong>地址寻访**</p></li><li><p>指令和数据用二进制表示</p></li><li><p>指令由操作码和地址码组成</p></li><li><p>存储程序</p></li><li><p>以<strong>运算器</strong>为中心</p></li></ol><p>冯·诺依曼计算机硬件框图</p><img src="http://note.lizhihao999.cn/notes/20200829182113.png" style="zoom:50%;"><h2 id="二-计算机硬件框图"><a href="#二-计算机硬件框图" class="headerlink" title="二.计算机硬件框图"></a>二.计算机硬件框图</h2><ol><li><p>以存储器为中心的计算机硬件框图</p><img src="http://note.lizhihao999.cn/notes/20200829182136.png" style="zoom:50%;"></li><li><p>现代计算机硬件框图</p></li></ol><img src="http://note.lizhihao999.cn/notes/20200829182153.png" style="zoom:80%;"><img src="http://note.lizhihao999.cn/notes/20200829182209.png" style="zoom:50%;"><p>##　三．计算机的工作步骤</p><h3 id="1-上机前的准备"><a href="#1-上机前的准备" class="headerlink" title="1.上机前的准备"></a>1.上机前的准备</h3><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序<ul><li>程序——运算的<strong>全部步骤</strong></li><li>指令——每<strong>一个步骤</strong></li></ul></li></ol><p>指令格式:<strong>操作码+地址码</strong></p><h3 id="2-计算机的解题过程"><a href="#2-计算机的解题过程" class="headerlink" title="2.计算机的解题过程"></a>2.计算机的解题过程</h3><h4 id="1-存储器的基本组成"><a href="#1-存储器的基本组成" class="headerlink" title="(1) 存储器的基本组成"></a>(1) 存储器的基本组成</h4><img src="http://note.lizhihao999.cn/notes/20200829182230.png" style="zoom:50%;"><ul><li><p>存储体 $\to$ 存储单元 $\to$ 存储元件 (<strong>0/1</strong>)</p><ul><li>存储元件：用来存放一位二进制信息</li><li>存储单元: 存放一串二进制代码(字长)</li><li>存储体：许多个存储单元可组成存储矩阵</li><li>存储字:存储单元中二进制代码的组合，可表示<ul><li>数值</li><li>指令</li><li>地址</li><li>逻辑数……</li></ul></li><li>存储字长: 每个存储单元中二进制代码的位数</li><li>按<strong>地址寻访</strong></li></ul></li><li><p><strong>MAR 存储器地址寄存器</strong> （A-Address）</p><ul><li>反应<strong>存储单元的个数</strong></li><li>$存储单元个数=2^{MAR位数}$</li></ul></li><li><p><strong>MDR 存储器数据寄存器</strong>（D-Data）</p><ul><li>反应<strong>存储字长</strong></li><li>$存储字长=MDR位数$</li></ul></li></ul><h4 id="（2）运算器的基本组成及操作过程"><a href="#（2）运算器的基本组成及操作过程" class="headerlink" title="（2）运算器的基本组成及操作过程"></a>（2）运算器的基本组成及操作过程</h4><p><strong>基本组成</strong></p><img src="http://note.lizhihao999.cn/notes/20200829182243.png" style="zoom:50%;"><p><strong>操作过程</strong></p><table><thead><tr><th align="center"></th><th align="center">累加器ACC</th><th align="center">乘商寄存器MQ</th><th align="center">操作数寄存器X</th></tr></thead><tbody><tr><td align="center">加法</td><td align="center">被加数&amp;和</td><td align="center"></td><td align="center">加数</td></tr><tr><td align="center">减法</td><td align="center">被减数&amp;差</td><td align="center"></td><td align="center">减数</td></tr><tr><td align="center">乘法</td><td align="center">乘积高位</td><td align="center">乘数&amp;乘积低位</td><td align="center">被乘数</td></tr><tr><td align="center">除法</td><td align="center">被除数&amp;余数</td><td align="center">商</td><td align="center">除数</td></tr></tbody></table><p>被操作数始终存放于累加器ACC中，操作数存放在操作数寄存器X。加减法的最终结果存放于累加器ACC。</p><ul><li><p>加法操作过程</p><img src="http://note.lizhihao999.cn/notes/20200829182306.png" style="zoom:50%;"></li><li><p>减法操作过程</p><img src="http://note.lizhihao999.cn/notes/20200829182316.png" style="zoom:50%;"></li><li><p>乘法操作过程</p><img src="http://note.lizhihao999.cn/notes/20200829182325.png" style="zoom:50%;"></li><li><p>除法操作过程</p></li></ul><img src="http://note.lizhihao999.cn/notes/20200829182335.png" style="zoom:50%;"><h4 id="（3）控制器基本组成"><a href="#（3）控制器基本组成" class="headerlink" title="（3）控制器基本组成"></a>（3）控制器基本组成</h4><img src="http://note.lizhihao999.cn/notes/20200829182350.png" style="zoom:50%;"><ul><li><p><strong>PC</strong>——程序计数器</p><ul><li>存放当前欲执行<strong>指令的地址</strong></li><li>具有计数功能</li><li>$(PC)+1\to PC$</li></ul></li><li><p><strong>IR</strong>——指令寄存器</p><ul><li>存放当前欲执行的<strong>指令</strong></li></ul></li><li><p>功能</p><ul><li>解释指令</li><li>保证指令的按序执行</li></ul></li></ul><h4 id="（4）主机完成一条指令的过程"><a href="#（4）主机完成一条指令的过程" class="headerlink" title="（4）主机完成一条指令的过程"></a>（4）主机完成一条指令的过程</h4><img src="http://note.lizhihao999.cn/notes/20200830093559.png" style="zoom:80%;"><p><strong>取数指令</strong></p><img src="http://note.lizhihao999.cn/notes/20200829182441.png" style="zoom:50%;"><ol><li>取指令1-4<ol><li>指令地址从<strong>PC</strong>放入<strong>MAR</strong></li><li>指令地址由<strong>MAR</strong>送至<strong>存储体</strong></li><li>指令被<strong>存储体</strong>送入<strong>MDR</strong></li><li>指令由<strong>MDR</strong>送至<strong>IR</strong></li></ol></li><li>分析指令5<ol><li>指令由<strong>IR</strong>送至<strong>CU</strong>进行分析</li></ol></li><li>执行指令6-9<ol><li>数据地址由<strong>IR</strong>传到<strong>MAR</strong></li><li>数据被<strong>存储体</strong>送到<strong>MDR</strong></li><li>数据被<strong>MDR</strong>送到<strong>ACC</strong></li></ol></li></ol><p><strong>存数指令</strong>（执行指令不同）</p><img src="http://note.lizhihao999.cn/notes/20200829182401.png" style="zoom:50%;"><h4 id="（5）-ax-2-bx-c-程序的运行过程"><a href="#（5）-ax-2-bx-c-程序的运行过程" class="headerlink" title="（5） $ax^2+bx+c$ 程序的运行过程"></a>（5） $ax^2+bx+c$ 程序的运行过程</h4><ol><li><p>将程序通过输入设备送至计算机</p></li><li><p>程序首地址**$\to$PC**</p></li><li><p>启动程序运行</p></li><li><p>取指令 <strong>PC$\to$MAR$\to$M$\to$MDR$\to$IR</strong>, <strong>(PC) + 1$\to$PC</strong></p></li><li><p>分析指令<strong>OP(IR)$\to$CU</strong></p></li><li><p>执行指令<strong>Ad(IR)$\to$MAR$\to$M$\to$MDR$\to$ACC</strong></p><p>……</p></li><li><p>打印结果</p></li><li><p>停机</p></li></ol><h1 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h1><ol><li><p>机器字长$\to$CPU一次能处理数据的位数</p><ul><li>通常与CPU的寄存器位数有关</li></ul></li><li><p>运算速度</p><p>普遍采用单位时间内执行指令的平均条数来衡量，并用MIPS作为计量单位。</p><ul><li><strong>主频</strong></li><li><strong>核数</strong>$\to$ 每个核支持的线程数</li><li><strong>吉普森法</strong> $\to$ $T_M=\sum_{i=1}^{n}f_it_i$<ul><li>$T_M$为机器运行速度</li><li>$f_i$为第i种指令占全部操作的百分比数</li><li>$t_i$为第i种指令的执行时间</li></ul></li><li><strong>CPI</strong>  $\to $ 执行一条指令所需时钟周期数（<strong>平均值</strong>）</li><li><strong>MIPS</strong> $\to $ 每秒执行百万条指令（还取决于<strong>指令复杂程度</strong>）</li><li><strong>FLOPS</strong> $\to$ 每秒浮点运算次数</li></ul></li><li><p>存储容量$\to$存放二进制信息的总位数</p><ul><li>主存容量<ul><li>存储单元个数×存储字长<ul><li>MAR10，MDR8$\to$ 1K×8位</li><li>MAR16，MDR32$\to$ 64K×32位</li><li>$1K=2^\text{10}$</li></ul></li><li>字节数<ul><li>$2^\text{13}b=1KB$</li><li>$2^\text{21}b=256KB$</li></ul></li></ul></li><li>辅存容量<ul><li>字节数$1GB=2^\text{30}b$</li></ul></li></ul></li></ol><h1 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h1><ol><li><p>三个字长</p><table><thead><tr><th align="center">字长</th><th align="center">定义</th><th align="center"></th></tr></thead><tbody><tr><td align="center">存储字长</td><td align="center">每个存储单元中二进制代码的位数</td><td align="center"></td></tr><tr><td align="center">机器字长</td><td align="center">CPU一次能处理数据的位数</td><td align="center">与CPU的寄存器位数有关</td></tr><tr><td align="center">指令字长</td><td align="center">一条指令的位数（操作码+地址码）</td><td align="center">与指令寄存器位数有关</td></tr></tbody></table></li></ol><ol start="2"><li><p>如何区分存放在存储器中的指令和数据</p><p>完成一条指令有三个步骤$\begin{cases}\text{取指令}\\text{分析指令}\\text{执行指令} \end{cases}$，其中需要两次访问内存，可依此分为两个阶段：取指阶段$\begin{cases}\text{取指令}\\text{分析指令}\end{cases}$取出<strong>指令</strong>、执行阶段$\begin{cases}\text{执行指令}\end{cases}$取出<strong>操作数</strong>，CPU根据阶段的不同可以判断取出的是指令还是数据：</p><ul><li>取指阶段取出：指令</li><li>执行阶段取出：数据</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摊还分析</title>
      <link href="/2020/05/10/tan-huan-fen-xi/"/>
      <url>/2020/05/10/tan-huan-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>在摊还分析中，我们求数据结构的一个操作序列中所执行的所有操作的<strong>平均时间</strong>，来评价操作的代价。摊还分析不同于平均情况分析，不涉及概率，保证<strong>最坏情况下每个操作的平均性能</strong>。通过做摊还分析，通常可以获得对某种特定数据结构的认识，这种认识有助于优化设计。</p><h1 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h1><p>利用聚合分析，我们证明对所有n，一个n个操作序列<strong>最坏情况</strong>下花费的总时间为T(n)。因此，在最坏情况下，每个操作的平均代价，或者是<strong>摊还代价</strong>为$\frac{T(n)}{n}$。需要注意的是，此摊还代价是适用于每个操作的，即使序列中有多种类型的操作也是如此。因此在这种方法中一个操作序列中不同的操作具有相同的摊还时间。</p><h1 id="核算法"><a href="#核算法" class="headerlink" title="核算法"></a>核算法</h1><p>在用核算法进行摊还分析时，我们对不同的操作赋予不同费用，我们将赋予一个操作的费用称为它的摊还代价，因此在核算法中，不同的操作具有不同的摊还代价。当一个操作的摊还代价超出其实际代价时，我们将差额存入到<strong>数据结构中的特定对象</strong>中，存入的差额称为<strong>信用</strong>，对于后续操作中摊还代价小于实际代价的情况，信用可以用来支付差额。因此我们可以将一个操作的摊还代价分解为实际代价和信用。不同的操作可能有不同的摊还代价。</p><p>我们必须小心的选择操作的摊还代价，以保证对所有操作序列来说，其<strong>摊还代价总和会大于等于其实际代价的总和</strong>。如果用$c_i$表示第i个操作的真实代价，用$\hat{c_i}$表示其摊还代价，则对任意n个操作的序列，要求<br>$$<br>\sum_{i=1}^{n}{\hat{c_i}}\ge\sum_{i=1}^{n}{c_i}<br>$$<br>数据结构中存储的信用恰好等于总摊还代价与总实际代价的差值，即$\sum_{i=1}^{n}{\hat{c_i}}-\sum_{i=1}^{n}{c_i}$。数据结构所关联的信用必须一直为非负值，即要保证<strong>数据结构中的总信用永远为非负</strong>。</p><h1 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h1><p>势能法摊还分析并不将预付代价表示为数据结构中特定对象的信用，可是表示为势能，将势能释放即可用来支付未来操作的代价并且不同于核算法，我们是将势能与整个数据结构而不是特定对象联系在一起的。</p><p>势能法工作方式如下：</p><ol><li><p>对一个初始数据结构$D_0$执行n个操作。</p></li><li><p>对每个$i=1,2,…,n$，令$c_i$为第i个操作的实际代价，令$D_i$为在数据结构$D_{i-1}$上执行第i个操作得到的结果数据结构。</p></li><li><p>势函数$\Phi $将每个数据结构$D_i$映射到一个实数$\Phi(D_i)$，此值即为关联到数据结构$D_i$的势。</p></li><li><p>第i个操作的瘫痪代价$\hat{c_i}$用势函数$\Phi $定义为：<br>$$<br>\hat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})<br>$$</p></li></ol><p>因此，每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。n个操作的总摊还代价为：<br>$$<br>\sum_{i=1}^{n}{\hat{c_i}}=\sum_{i=1}^{n}{(c_i+\Phi(D_{i})-\Phi(D_{i-1}))}=\sum_{i=1}^{n}{c_i}+\Phi(D_n)-\Phi(D_0)<br>$$<br>如果对所有i，我们要求$\Phi(D_i)\ge\Phi(D_0)$，则可以像核算法一样保证总能提前支付。通常，我们将$\Phi(D_0)$简单定义为0，然后说明对所有i，有$\Phi(D_i)\ge 0$。</p><p>所以在进行势能法分析时，我们需要先确定一个势函数，然后再通过关系式去求解每个操作的摊还代价。此势函数应该<strong>要满足对所有操作序列，其值应要大于等于0</strong>。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络最大流</title>
      <link href="/2020/05/09/wang-luo-zui-da-liu/"/>
      <url>/2020/05/09/wang-luo-zui-da-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h1><h2 id="流网络和流"><a href="#流网络和流" class="headerlink" title="流网络和流"></a>流网络和流</h2><p>流网络$G=(V,E)$，是一个有向图，图中每条边$(u,v)\in E$有一个非负的<strong>容量值</strong>$c(u,v)\ge 0$。而且不存在平行反向边，即如果存在边$(u,v)$，便不存在反方向的边$(v,u)$。如果$(u,v)\notin E$，定义$c(u,v)=0$，并且在图中不允许自循环。</p><p>所有结点中定义两个特殊结点：<strong>源结点s</strong>和<strong>汇点t</strong>。假定每个结点都在从源结点到汇点的某条路径上。所以，对于每个结点$v\in V$，流网络都包括一条路径$s\rightsquigarrow v\rightsquigarrow t$。因此，流网络是连通的，$|E|\ge |V|-1$。</p><img src="http://note.lizhihao999.cn/notes/20200824164601.png" alt="《算法导论》流网络示例" style="zoom: 67%;"><p>设流网络$G=(V,E)$，其容量函数为c。设s为网络的源结点，t为汇点。G中的流是一个实值函数$f:V\times V\to R$，满足：</p><ul><li><p><strong>容量限制</strong></p><p>对于所有的结点$u,v\in V$，要求$0\le f(u,v)\le c(u,v)$</p></li><li><p><strong>流量守恒</strong></p><p>对于所有的结点$u\in V-{s,t}$，要求<br>$$<br>\sum_{v\in V}{f(v,u)}=\sum_{v\in V}{f(u,v)}<br>$$</p></li></ul><p>当$(u,v)\notin E$时，从结点u到结点v之间没有流，因此$f(u,v)=0$。</p><p>称非负值$f(u,v)$为从结点u到结点v的流。</p><p>一个流$f$的值$|f|$定义如下：<br>$$<br>|f|=\sum_{v\in V}{f(s,v)}-\sum_{v\in V}{f(v,s)}<br>$$<br>流$f$的值是从源结点流出的总流量减去流入源结点的总流量。</p><p><strong>最大流问题</strong>中，给定一个流网络G，一个源结点s，一个汇点t，希望找到值最大的一个流。</p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p>Ford-Fulkerson方法循环增加流的值，在开始的时候，对于所有结点$u,v\in V,f(u,v)=0$，给出的初始流值为0。在每一次迭代中，我们将图G的流值进行增加，方法就是在一个关联的“残存网络”$G_f$中寻找一条“增广路径”。一旦知道图$G_f$中一条增广路径的边，就可以很容易辨识出G中的一些具体的边，我们可以对这些边上的流量进行修改，从而增加流的值。虽然Ford-Fulkerson方法每次迭代都能增加流的值，但是对于图G的一条特定边来说，其流量可能增加也可能减少；对于某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。重复对流进行这一过程，直到残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。</p><pre class="line-numbers language-c"><code class="language-c">FORD<span class="token operator">-</span>FILKERSON<span class="token operator">-</span><span class="token function">METHOD</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>s<span class="token punctuation">,</span>t<span class="token punctuation">)</span>    initial flow f to <span class="token number">0</span>    <span class="token keyword">while</span> there exists an augmenting path p in the residual network Gf        augment flow f along p    <span class="token keyword">return</span> f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>给定流网络G和流量f，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。流网络的一条边可以允许的额外容量等于该边的容量减去该边上的流量。如果差值为正，则将该条边置于图$G_f$中，并将其残存容量设置为$c_f(u,v)=c(u,v)-f(u,v)$。对于图G中的边来说，只有能够允许额外流量的边才能加入到图$G_f$中。如果边$(u,v)$的流量等于其容量，则$c_f(u,v)=0$，该条边将不属于图$G_f$</p><p>假定有一个流网络$G=(V,E)$，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对$u,v\in V$，定义残存容量$c_f(u,v)$如下：</p><img src="http://note.lizhihao999.cn/notes/20200824161054.png" style="zoom:67%;"><p>给定一个流网络$G=(V,E)$，和一个流$f$，则由$f$所诱导的图G的残存网络为$G_f=(V,E_f)$，其中<br>$$<br>E_f={(u,v)\in V\times V:c_f(u,v)&gt;0}<br>$$<br>如果$f$是G的一个流，$f’$是对应的残存网络$G_f$中的一个流，定义$f\uparrow f’$为流$f’$对流$f$的递增，他是一个从$V\times V$到R的函数：</p><img src="http://note.lizhihao999.cn/notes/20200824161132.png" style="zoom: 80%;"><p>因为在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边$(u,v)$的流量增加$f’(u,v)$，但减少$f’(v,u)$。在残存网络中将流量推送回去也称为<strong>抵消操作</strong>。</p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p>给定流网络$G=(V,E)$和流$f$，增广路径p是残存网络$G_f$中一条从源结点s到汇点t的简单路径。根据残存网络的定义，对于一条增广路径上的边$(u,v)$，我们可以增加其流量的幅度最大为$c_f(u,v)$，而不会违反原始流网络G对边$(u,v)$或$(v,u)$的容量限制。</p><p>称在一条增广路径p上能够为每条边增加的流量的最大值为路径p的残存容量：<br>$$<br>c_f(p)=\min{c_f(u,v):(u,v)属于路径p}<br>$$</p><h2 id="流网络的切割"><a href="#流网络的切割" class="headerlink" title="流网络的切割"></a>流网络的切割</h2><p>流网络$G=(V,E)$中的一个切割$(S,T)$将结点集合V划分为S和$T=V-S$两个集合，使得$s\in S,t\in T$，若$f$是一个流，则定义横跨切割$(S,T)$的净流量$f(S,T)$：<br>$$<br>f(S,T)=\sum_{u\in S}{\sum_{v\in T}{f(u,v)}}-\sum_{u\in S}{\sum_{v\in T}f(v,u)}<br>$$<br>切割$(S,T)$的容量是：<br>$$<br>c(S,T)=\sum_{u\in S}{\sum_{v\in T}{c(u,v)}}<br>$$<br>一个网络的最小切割是整个网络中容量最小的切割。</p><blockquote><p><strong>最大流最小切割定理</strong></p><p>设$f$为流网络$G=(V,E)$中的一个流，该流网络的源结点为$s$，汇点为$t$，则下面的条件是等价的：</p><ol><li>$f$是$G$的一个最大流</li><li>残存网络$G_f$不包括任何增广路径</li><li>$|f|=c(S,T)$，其中$(S,T)$是流网络G的某个切割</li></ol></blockquote><h1 id="基本Ford-Fulkerson算法"><a href="#基本Ford-Fulkerson算法" class="headerlink" title="基本Ford-Fulkerson算法"></a>基本Ford-Fulkerson算法</h1><p>假设流网络的容量$c(u,v)$都已经给出，如果边$(u,v)\notin  E$，则$c(u,v)=0$。</p><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">FORD-FILKERSON(G,s,t)    /* 将流f初始化为0 */    for each edge(u,v) in G.E        (u,v).f = 0    /* 重复在残存网络Gf中寻找一条增广路径p */    while there exsits a path p from s to t in the residual network Gf        cf(p) = min&#123;cf(u,v): (u,v) is in p&#125;        /* 使用残存容量cf(p)对路径p上的流f进行加赠 */        for each edge(u,v) in p            if (u,v) in E                (u,v).f = (u,v).f + cf(p)            else                (v,u).f = (v,u).f - cf(p)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>2~3行：将流$f$初始化为0</li><li>4~9行while循环：重复在残存网络$G_f$中寻找一条增广路径p，然后使用残存容量$c_{f}(p)$来对路径p上的流$f$进行加增。路径p上每条残存边要么是原来网络中的一条边，要么是原来网络中的边的反向边。<ol><li>7~9行：针对每种情况对流进行相应的更新：<ul><li>如果残存边是原来网络中的一条边，则增加流量，否则缩减流量</li><li>当不再有增广路径时，流$f$就是最大流</li></ul></li></ol></li></ol><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>Ford-Fulkerson算法的运行时间取决于算法第4行如何寻找增广路径。while循环的次数最多为$|f^*|$次，因为流量值在每次迭代中最少增加一个单位；每执行一次的时间为$O(E)$。从而整个Ford-Fulkerson算法的运行时间为$O(E|f^*|)$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所有结点对最短路径</title>
      <link href="/2020/05/08/suo-you-jie-dian-dui-de-zui-duan-lu-jing/"/>
      <url>/2020/05/08/suo-you-jie-dian-dui-de-zui-duan-lu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法利用<strong>动态规划</strong>来解决所有结点对最短路径问题，运行时间为$O(V^3)$。假设负权重的边可以存在，但不能存在负权重的环路。</p><p>使用<strong>邻接矩阵W</strong>来表示图，矩阵W是一个$n\times n$的矩阵W，该矩阵代表的是一个有n个结点的有向图$G=(V,E)$的边的权重，即$W=(w_{ij})$其中</p><img src="http://note.lizhihao999.cn/notes/20200824144945.png" style="zoom:67%;"><h2 id="最短路径的结构"><a href="#最短路径的结构" class="headerlink" title="最短路径的结构"></a>最短路径的结构</h2><p>Floyd算法考虑一条最短路径上的中间结点，即简单路径$p=&lt;v_1,v_2,..,v_n&gt;$上的中间结点指路径p上除了$v_1,v_n$之外的任意结点，将中间结点作为集合：${v_2,v_3,…,v_{n-1}}$</p><p>假定图G的所有结点为$V={1,2,..,n}$，考虑其中的一个子集${1,2,…,k}$，这里k是某个小于n的整数。对于任意结点对$i,j\in V$，考虑从结点$i$到结点$j$的所有中间结点均取自集合${1,2,…,k}$的路径，并且设$p$为其中权重最小的路径（$p$是简单路径）。Floyd算法利用路径$p$和从$i$到$j$之间中间结点均取自集合${1,2,…,k-1}$的最短路径之间的关系。该关系依赖于结点$k$是否是路径$p$上的一个中间结点。</p><ul><li><p>如果结点$k$不是路径$p$上的一个中间结点，则路径$p$上的所有中间结点都属于集合${1,2,..,k-1}$。因此从结点$i$到结点$j$的中间结点取自集合${1,2,…,k-1}$的一条最短路径也是从结点$i$到结点$j$的中间结点取自集合${1,2,…,k}$的一条最短路径。</p></li><li><p>如果结点$k$是路径$p$上的一个中间结点，则将路径$p$分解为$i\rightsquigarrow^{p_1}k\rightsquigarrow^{p_2}j$，如图所示。</p><img src="http://note.lizhihao999.cn/notes/20200824145123.png" style="zoom:67%;"><p>$p_1$是从结点$i$到结点k的中间结点全部取自集合${1,2,…,k}$的一条最短路径。事实上，因为$k$不是路径$p_1$上的中间结点，路径$p_1$上的所有中间结点都属于集合${1,2,…,k-1}$的一条最短路径。类似地，$p_2$是从结点$k$到结点$j$的中间结点全部取自集合${1,2,…,k-1}$的一条最短路径。</p></li></ul><h2 id="所有结点对最短路径问题的一个递归解"><a href="#所有结点对最短路径问题的一个递归解" class="headerlink" title="所有结点对最短路径问题的一个递归解"></a>所有结点对最短路径问题的一个递归解</h2><p>设$d_{ij}^{(k)}$为从结点$i$到结点$j$的所有中间结点全部取自集合${1,2,…,k}$的一条最短路径的权重。当$k=0$时，从结点$i$到结点$j$的一条不包括编号大于0的中间结点的路径将没有任何中间结点。这样的路径最多只有一条边，因此$d_{ij}^{(0)}=w_{ij}$。根据上面的讨论，递归定义:</p><img src="http://note.lizhihao999.cn/notes/20200824155308.png" style="zoom:67%;"><p>因为对于任何路径来说，所有的中间结点都属于集合${1,2,….n}$，矩阵$D^{(n)}=(d_{ij}^{(n)})$给出的就是最终答案：<br>$$<br>对于所有的i,j\in V,d_{ij}^{(n)}=\delta(i,j)<br>$$</p><h2 id="自底向上计算最短路径权重"><a href="#自底向上计算最短路径权重" class="headerlink" title="自底向上计算最短路径权重"></a>自底向上计算最短路径权重</h2><p>算法输入为一个$n\times n$的矩阵$W$，下面的算法返回的是最短路径权重矩阵$D^{n}$：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">FLOYD</span><span class="token punctuation">(</span>W<span class="token punctuation">)</span>    n <span class="token operator">=</span> W<span class="token punctuation">.</span>rows    D<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">=</span> W    <span class="token keyword">for</span> k<span class="token operator">=</span><span class="token number">1</span> to n        let D<span class="token operator">^</span>k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">^</span>k<span class="token punctuation">)</span> be a new n<span class="token operator">*</span>n matrix        <span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span> to n            <span class="token keyword">for</span> j<span class="token operator">=</span><span class="token number">1</span> to n                <span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">^</span>k <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">d</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> D<span class="token operator">^</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构建一条最短路径"><a href="#构建一条最短路径" class="headerlink" title="构建一条最短路径"></a>构建一条最短路径</h2><p>可以先计算最短路径权重矩阵D然后从D矩阵来构造前驱矩阵$\Pi$，或者在计算矩阵$D^{(k)}$的同时计算前驱矩阵$\Pi$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> INFI <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> NIL <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">floyd</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> W<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> P<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> W<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> D <span class="token operator">=</span> W<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> D<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print_matrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> W<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> w <span class="token operator">:</span> W<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> item <span class="token operator">:</span> w<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> item <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 打印最短路径</span><span class="token keyword">void</span> <span class="token function">print_path</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> P<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> P<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span> <span class="token operator">&lt;&lt;</span> P<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> P<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 结点数量</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">W</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector <span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        W<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INFI<span class="token punctuation">)</span><span class="token punctuation">;</span>        W<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> NIL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 边的数量</span>    cin <span class="token operator">>></span> a<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// u、v：端点，w：边的权重</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> w<span class="token punctuation">;</span>        W<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>        P<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">print_matrix</span><span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_matrix</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> D <span class="token operator">=</span> <span class="token function">floyd</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_matrix</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_matrix</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_path</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> P<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路径</title>
      <link href="/2020/05/07/dan-yuan-zui-duan-lu-jing/"/>
      <url>/2020/05/07/dan-yuan-zui-duan-lu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><p>在该问题中，给定一个带权重的有向图$G=(V,E)$和权重函数$w:E\to R$，该权重函数将每条边映射到实数值的权重上。图中一条路径$p=&lt;v_0,v_1,…,v_k&gt;$的<strong>权重</strong>$w(p)$是构成该路径的所有边的权重之和：<br>$$<br>w(p)=\sum_{i=1}^{k}{w(v_{i-1},v_i)}<br>$$<br>定义从结点u到结点v的<strong>最短路径权重</strong>$\delta(u,v)$：</p><img src="http://note.lizhihao999.cn/notes/20200824000613.png" style="zoom: 80%;"><p>从结点u到结点v的<strong>最短路径</strong>则定义为任何一条权重为$w(p)=\delta(u,v)$的从u到v的路径p</p><h1 id="最短路径的表示"><a href="#最短路径的表示" class="headerlink" title="最短路径的表示"></a>最短路径的表示</h1><p>给定图$G=(V,E)$，对于每个结点点v，维持一个**前驱结点$v.\pi$**。该前驱结点可能是另一个结点或者NIL。当给定结点v，且$v.\pi\ne NIL$时，从结点v开始将前驱结点链反转就是从s到v的一条最短路径。</p><p>我们对由$\pi$值引导的<strong>前驱子图</strong>$G_\pi=(V_\pi,E_\pi)$感兴趣。我们定义结点集$V_\pi$为图G中的前驱结点不为NIL的结点的集合，再加上源结点s，即<br>$$<br>V_\pi={v\in V:v.\pi\ne NIL}\bigcup{s}<br>$$<br>有向边集合$E_\pi$是由$V_\pi$中的结点的$\pi$值所诱导的边的集合，即<br>$$<br>E_\pi={(v.\pi,v)\in E:v\in V_\pi-{s}}<br>$$<br>本章算法所生成的$\pi$值具有以下性质：</p><p>在算法终止时，$G_\pi$是一棵“最短路径树”，包括从源结点s到每个可以从s到达的结点的一条最短路径。一棵根结点为s的最短路径树是一个有向子图$G’=(V’,E’)$，这里$V’\subseteq V,E’\subseteq E$，满足：</p><ol><li>V‘是图G中从源结点s可以到达的所有结点的集合；</li><li>G’形成一棵根结点为s的树；</li><li>对于所有结点$v\in V’$，图G‘中从结点s到结点v的唯一简单路径是图G中从结点s到结点v的一条最短路径。</li></ol><p>需要指出，最短路径不一定唯一，最短路径树也不一定唯一。</p><h1 id="松弛-relaxation-操作"><a href="#松弛-relaxation-操作" class="headerlink" title="松弛(relaxation)操作"></a>松弛(relaxation)操作</h1><blockquote><p>最短路径算法的核心技术是<strong>松弛</strong>。</p></blockquote><p>对于每一个结点v，维持一个属性$v.d$，用来记录从源结点s到结点v的最短路径权重的上界，称$v.d$为s到v的<strong>最短路径估计</strong>。使用下面运行时间为$\Theta(V)$的算法来<strong>对最短路径估计和前驱结点进行初始化</strong>：</p><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">INITIALIZE-SINGLE-SOURCE(G,s)    for each vertex v in G.V        v.d = infinit        v.pi = NIL    s.d = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化之后，对于所有结点$v \in V$，我们有$v.\pi=NIL,s.d=0$，对于所有结点$v \in V-{s}$，我们有$v.d=\infin$。</p><p>对一条边的松弛过程为：首先测试是否可以对从s到v的最短路径进行改善。测试方法是：将从结点s到结点u之间的最短路径距离加上结点u与v之间的边权重，并与当前的s到v的最短路径估计进行比较，如果前者更小，则对$v.d$和$v.\pi$进行更新。松弛步骤可能降低最短路径的估计值$v.d$并更新v的前驱属性$v.\pi$。下面的伪代码执行对边$(u,v)$在$O(1)$时间内进行的松弛操作：</p><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">RELAX(u,v,w)    if v.d > u.d+w(u,v)        v.d = u.d + w(u,v)        v.pi = u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.lizhihao999.cn/notes/20200823225845.png" alt="《算法导论》松弛示例"></p><h1 id="最短路径和松弛操作的性质"><a href="#最短路径和松弛操作的性质" class="headerlink" title="最短路径和松弛操作的性质"></a>最短路径和松弛操作的性质</h1><ul><li><p><strong>三角不等式性质</strong></p><p>对于任何边$(u,v)\in E$，我们有$\delta (s,v)\le \delta(s,u)+w(u,v)$</p></li><li><p><strong>上界性质</strong></p><p>对于所有结点$v\in V$，总是有$v.d\ge\delta(s,v)$。一旦$v.d$的取值到达$\delta(s,v)$，其值不再发生变化。</p></li><li><p><strong>非路径性质</strong></p><p>如果从结点s到结点v之间不存在路径，则总是有$v.d=\delta(s,v)=\infin$</p></li><li><p><strong>收敛性质</strong></p><p>对于某些结点u，$v\in V$，如果$s\rightsquigarrow u\to v$是图G中的一条最短路径，并且在对边$(u,v)$进行松弛前的任意时间有$u.d=\delta(s,u)$，则在之后的所有时间有$v.d=\delta(s,v)$</p></li><li><p><strong>路径松弛性质</strong></p><p>如果$p = &lt;v_0,v_1,…,v_k&gt;$是从源结点$s=v_0$到结点$v_k$的一条最短路径，并且我们对p中的边所进行松弛的次序为$(v_0,v_1),(v_1,v_2),…,(v_{k-1},v_k)$，则$v_k.d=\delta(s,v_k)$。</p><p>该性质的成立与其他的松弛操作无关，即使这些操作是对p上的边所进行的松弛操作穿插进行的。</p></li><li><p><strong>前驱子图性质</strong></p><p>对于所有的结点$v\in V$，一旦$v.d=\delta(s,v)$，则前驱子图是一棵根结点为s的最短路径树。</p></li></ul><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是<strong>一般情况下的单源最短路径问题</strong>，在这里，<strong>边的权重可以为负值</strong>。给定带权重的有向图$G=(V,E)$，和权重函数$w:E\to R$，Bellman-Ford算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在这样一个环路，算法将告诉我们不存在解决方案。如果没有这种环路存在，算法将给出最短路径及它们的权重。</p><p>Bellman-Ford算法通过对边进行松弛操作来渐进地降低从源结点s到每个结点v的最短路径的估计值$v.d$，直到该估计值与实际最短路径权重$\delta(s,v)$相同为止。该算法返回TRUE值当且仅当输入图不包含可以从源结点到达的权重为负值的环路。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">BELLMAN_FORD</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">,</span>s<span class="token punctuation">)</span>    INITIALIZE<span class="token operator">-</span>SINGLE<span class="token operator">-</span><span class="token function">SOURCE</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 对所有结点的d值和pi值进行初始化</span>    <span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span> to <span class="token operator">|</span>G<span class="token punctuation">.</span>V<span class="token operator">|</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> each <span class="token function">edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in G<span class="token punctuation">.</span>E            <span class="token function">RELAX</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span>    <span class="token keyword">for</span> each <span class="token function">edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in G<span class="token punctuation">.</span>E        <span class="token keyword">if</span> v<span class="token punctuation">.</span>d <span class="token operator">></span> u<span class="token punctuation">.</span>d<span class="token operator">+</span><span class="token function">w</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span>            <span class="token keyword">return</span> FALSE    <span class="token keyword">return</span> TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>3~5行对图的每条边进行$|V|-1$次处理，每次处理对应一次循环，每次循环对每条边进行一次松弛操作。</li><li>6~8行检查图中是否存在权重为负值的环路并返回与之相适应的布尔值。</li></ol><p><img src="http://note.lizhihao999.cn/notes/20200823230510.png" alt="《算法导论》Bellman-Ford算法示例"></p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ol><li>初始化时间：$\Theta(V)$</li><li>3~5行循环运行时间：一次循环的时间为$\Theta(E)$，一共进行$|V|-1$次循环</li><li>6~8行for循环：$O(E)$</li></ol><p>Bellman-Ford算法的总运行时间：$O(VE)$</p><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求<strong>所有边的权重都为非负值</strong>，因此，我们假定对于所有的边$(u,v)\in E$，都有$w(u,v)\ge 0$。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合$S$。从源结点s到该集合每个结点之间的最短路径已经被找到。算法重复从结点集$V-S$中选择最短路径估计最小的结点$u$，将$u$加入到集合$S$，然后对所有从$u$出发的边进行松弛。</p><p>在下面给出的方法中我们使用一个最小优先队列$Q$来保持结点集合，每个结点的关键值为其d值。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">DIJKSTRA</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">,</span>s<span class="token punctuation">)</span>    INITIALIZE<span class="token operator">-</span>SINGLE<span class="token operator">-</span><span class="token function">SOURCE</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 对所有结点的d值和pi值进行初始化</span>    S <span class="token operator">=</span> Empty    <span class="token comment" spellcheck="true">// 将集合S初始化为一个空集</span>    Q <span class="token operator">=</span> G<span class="token punctuation">.</span>V        <span class="token comment" spellcheck="true">// 对最小优先队列Q进行初始化，将所有结点V放入队列</span>    <span class="token keyword">while</span> Q <span class="token operator">!=</span> Empty        u <span class="token operator">=</span> EXTRACT<span class="token operator">-</span><span class="token function">MIN</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span>        S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>u<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> each vertex v in G<span class="token punctuation">.</span>Adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span>            <span class="token function">RELAX</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>2行：对所有结点的d值和pi值进行初始化</li><li>3行：将集合S初始化为一个空集</li><li>4行：对最小优先队列Q进行初始化，将所有结点V放入队列</li><li>5~9行：始终维持不变式$Q=V-S$<ol><li>6行：从$Q=V-S$集合中抽取结点u，<strong>结点u为集合$V-S$中所有结点的最小最短路径估计</strong></li><li>7行：将结点u加入集合S，继续保持不变式</li><li>8~9行：对所有结点u发出的边$(u,v)$进行<strong>松弛操作</strong></li></ol></li></ol><h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>因为Dijkstra算法总是选择集合V-S中“最轻”或“最近”的结点加入集合S，所以该算法使用的是<strong>贪心策略</strong>。可以证明：使用贪心策略的Dijkstra算法确实可以计算出最短路径。</p><p>关键是证明这样一个事实：<strong>该算法在每次选择结点u加入集合S时，有$u.d=\delta(s,u)$.</strong></p><blockquote><p><strong>定理1</strong></p><p>Dijkstra算法运行在带权重的有向图$G=(V,E)$时，如果所有权重为非负值，则在算法终止时，对于所有结点$u\in V$，我们有$u.d=\delta(s,u)$</p></blockquote><p>证明：</p><blockquote><p>我们在算法中使用下面的循环不变式：</p><p>在算法5~9行while语句的每次循环开始前，对于每个结点$v\in S$，有$v.d=\delta(s,v)$</p></blockquote><p>只需要证明对于每个结点$u\in V$，当结点u被加入到集合S时，有$u.d=\delta(s,u)$。一旦证明，则可以使用上界欸性质来证明该等式在后续的所有时间内保持成立。</p><ol><li><p><strong>初始化</strong></p><p>初始时，$S=\empty$，因此循环不变式直接成立</p></li><li><p><strong>保持</strong></p><p>反证法证明：当结点u被加入到集合S时，有$u.d=\delta(s,u)$。</p><p>假设结点u是第一个加入到集合S时使得该方程不成立的结点，即$u.d\ne \delta(s,u)$</p><p>首先，初始结点s是第一个加入集合S的点，并且$s.d=\delta(s,s)=0$，所以结点s与结点u不同，即$s\ne u$</p><p>所以，当结点u加入集合S时，$S\ne\empty$。此时，一定存在某条从结点s到结点u的路径，否则根据非路径性质，有$u.d=\delta(s,u)=\infin$，违背假设$u.d\ne \delta(s,u)$。因为存在某条从结点s到结点u的路径，所以也存在一条从结点s到结点u的最短路径p。</p><p>将结点u加入集合S之前，路径p连接集合S中的结点s和集合$V-S$中的结点u；假设结点y是路径p上第一个满足$y\in V-S$的结点，设$x\in S$是结点y的前驱结点，如图所示，可以将路径p分解为$s\rightsquigarrow^{p_1}x\to y\rightsquigarrow^{p_2}u$（<strong>路径$p_1$或者$p_2$可能不包含任何边</strong>）</p><img src="http://note.lizhihao999.cn/notes/20200824104537.png" alt="定理1证明" style="zoom:80%;"><p>因为选择的结点u是第一个加入集合S并且$u.d\ne \delta(s,u)$的结点，所以当结点x加入集合S时，有$x.d=\delta(s,x)$，之后边$(x,y)$会被松弛，根据收敛性质可以得到：结点u加入集合S时，有$y.d=\delta(s,y)$</p><p>因为结点y是最短路径p上位于结点u之前的一个点，并且所有边的权重非负，所以有$\delta(s,y)\le\delta(s,u)$，因此<br>$$<br>y.d=\delta(s,y)\le\delta(s,u)\le u.d（上界性质）<br>$$<br>又因为，在选择结点u时，结点u和结点y都在集合$V-S$中，选中结点u，说明$u.d\le y.d$，所以上式的两个不等式都是等式成立，即<br>$$<br>y.d=\delta(s,y)=\delta(s,u)=u.d<br>$$<br>得到$u.d=\delta(s,u)$，与假设矛盾。因此，推断在结点u加入到集合S时，有$u.d=\delta(s,u)$，并且该等式在随后的所有时间内都保持成立。</p></li><li><p><strong>终止</strong></p><p>算法终止时，$Q=\empty$，又因为$Q=V-S$，说明$S=V$。因此，对于所有结点$u\in V$，有$u.d=\delta(s,u)$</p></li></ol><blockquote><p><strong>推论1</strong></p><p>如果在带权重的有向图$G=(V,E)$上运行Dijkstra算法，其中权重皆为非负值，源结点为s，则在算法终止时，前驱子图$G_{\pi}$是一棵根结点为s的最短路径树。</p></blockquote><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>该算法执行三种优先队列操作来维持最小优先队列：</p><ul><li><code>INSERT</code>：$O(1)$</li><li><code>EXTRACT-MIN</code>：$O(V)$，需要搜索整个数组</li><li><code>DECREASE-KEY</code>：$O(1)$</li></ul><p>该算法对每个结点调用一次<code>INSERT</code>和<code>EXTRACT-MIN</code>操作，。因为每个结点仅被加入到集合S一次，邻接表<code>Adj[u]</code>中的每条边在整个算法运行期间也只被检查一次（<strong>for循环中</strong>）。所有邻接表中的边的总数为$|E|$，该for循环一共执行$|E|$次，即最多调用<code>DECREASE-KEY</code>$|E|$次。</p><p>Dijkstra算法的运行时间依赖于最小优先队列的实现。</p><p>如果利用编号$1\to|V|$来维持最小优先队列。这种情况下，我们将<code>v.d</code>的值存放在数组的第v个记录里。算法总运行时间为：$O(V^2+E)=O(V^2)$</p><p>实际上，我们可以将Dijkstra算法的运行时间改善到$O(V\lg{V}+E)$，方法是斐波那契堆来实现最小优先队列。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2020/05/06/zui-xiao-sheng-cheng-shu/"/>
      <url>/2020/05/06/zui-xiao-sheng-cheng-shu/</url>
      
        <content type="html"><![CDATA[<p>用$G=(V,E)$表示连通无向图，并且对于每条边$(u,v)\in E$，为其赋予权重$w(u,v)$。我们希望找到一个无环子集$T\subseteq E$，既能够将所有的节点连接起来，又具有最小的权重。由于T是无环的，并且连通所有结点，因此T是一棵树，称T为（图G的）<strong>生成树</strong>。称求取该生成树的问题为<strong>最小生成树问题</strong>。</p><p>讨论的两种解决最小生成树问题的两种算法：Kruskal算法和Prim算法都是贪心算法。贪心算法的每一步必须在多个可能的选择中选择一种。贪心算法推荐选择在当前看来最好的选择。这种策略一般并不能保证找到一个全局最优的解决方案。但是，对于最小生成树问题来说，可以证明某些贪心策略确实能够找到一棵权重最小的生成树。</p><h1 id="最小生成树的形成"><a href="#最小生成树的形成" class="headerlink" title="最小生成树的形成"></a>最小生成树的形成</h1><p>假设有一个连通无向图$G=(V,E)$和权重函数$w:E\to R$，两种算法都采用贪心策略，但方式不同。贪心策略可以用下面的通用方式来表示。</p><p>该通用方式在每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，管理一个遵守下述循环不变式的边集合A：<br>$$<br>在每遍循环之前，A是某棵最小生成树的一个子集<br>$$<br>在每一步，选择一条边$(u,v)$，将其加入到集合A中，使得A不违反循环不变式，即$A\bigcup{(u,v}$也是某棵最小生成树的子集。由于可以安全地将这种边加入到集合A而不会破坏A的循环不变式，因此称这样的边为集合A的<strong>安全边</strong>。</p><pre class="line-numbers language-c"><code class="language-c">GENERIC<span class="token operator">-</span><span class="token function">MST</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">)</span>    A <span class="token operator">=</span> Ø    <span class="token keyword">while</span> A does not form a spanning tree        find an <span class="token function">edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> that is safe <span class="token keyword">for</span> A        A <span class="token operator">=</span> A∪<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用循环不变式的方式：</p><ul><li><p><strong>初始化</strong></p><p>在算法第2行之后，集合A直接满足循环不变式。</p></li><li><p><strong>保持</strong></p><p>算法第3~5行循环通过只加入安全边来维持循环不变式。</p></li><li><p><strong>终止</strong></p><p>所有加入到集合A的边都属于某棵最小生成树，因此，算法第5行所返回的集合A必然是一颗最小生成树。</p></li></ul><p>该算法最关键的是第3行：找到一条安全边。这条安全边必然存在，因为在执行算法第3行时，循环不变式告诉我们存在一棵生成树T，满足$A\subseteq T$。在第2~4行的while循环体内，集合A一定是T的真子集，因此，必然存在一条边$(u,v)\in T$，使得$(u,v)\in T$，使得$(u,v)\in T$，使得$(u,v)\notin A$，并且$(u,v)$对于集合A是安全的。</p><p>Kruskal算法和Prim算法就是如何快速找到安全边的算法。</p><h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>也称“加边法”，初始时，最小生成树集合里面包含所有顶点，但不包含任何边，每迭代一次就选择一条满足要求的边加入到集合里。</p><pre class="line-numbers language-c"><code class="language-c">MST<span class="token operator">-</span><span class="token function">KRUSKAL</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">)</span>    A <span class="token operator">=</span> Ø    <span class="token keyword">for</span> each vertex v∈G<span class="token punctuation">.</span>V        MAKE<span class="token operator">-</span><span class="token function">SET</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>    sort the edges of G<span class="token punctuation">.</span>E into nondecreasing orger by weight w    <span class="token comment" spellcheck="true">// 按升序对边进行排序</span>    <span class="token keyword">for</span> each <span class="token function">edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span>∈G<span class="token punctuation">.</span>E<span class="token punctuation">,</span> taken in nondecreasing order by weight        <span class="token keyword">if</span> FIND<span class="token operator">-</span><span class="token function">SET</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>≠FIND<span class="token operator">-</span><span class="token function">SET</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 判断结点u，v是否属于同一棵树</span>            A<span class="token operator">=</span>A∪<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token function">UNION</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 合并两棵树</span>    <span class="token keyword">return</span> A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>2~4行将集合A初始化为一个空集合，并创建$|V|$棵树，每棵树包含一个结点。</li><li>5~9行的<strong>for循环</strong>按照权重从低到高的次序对每条边逐一进行检查。对于每条边$(u,v)$来说，该循环将检查端点u和端点v是否属于同一棵树。<ul><li>如果是，该条边不能加入到森林里，否则会形成环路；</li><li>如果不是，两个端点分别属于不同的树，算法第8行将该条边加入集合A，第9行将两棵树中的结点进行合并。</li></ul></li></ol><p><img src="http://note.lizhihao999.cn/notes/20200823140749.png" alt="《算法导论》示例"></p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><ol><li>第2行对集合A进行初始化：$O(1)$</li><li>第5行对边进行排序：$O(E\lg{E})$</li><li>第6~9行的for循环，执行$O(E)$个FIND-SET和UNION操作以及$|V|$个MAKE-SET操作，总运行时间为：$O((V+E)\alpha(V))$</li></ol><p>$\alpha$是定义的一个增长非常缓慢的函数，假定图G是连通的，则有$|E|\ge |V|-1$，所以不相交集合操作的时间代价为$O(E\alpha(V))$。而且，由于$\alpha(|V|)=O(\lg{V})=O(\lg{E})$，Kruskal算法的总运行时间为$O(E\lg{E})$。</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><h3 id="贪心选择性"><a href="#贪心选择性" class="headerlink" title="贪心选择性"></a>贪心选择性</h3><p>只需证明每一步得到的边的集合，都是最小生成树的子集。</p><blockquote><p><strong>定理1</strong></p><p>设$(u,v)$是G中权值最小的边，则必有一棵最小生成树包含边$(u,v)$</p></blockquote><p>证明：</p><p>设T是G的一棵最小生成树，若$(u,v)\in T$，结论成立；</p><p>否则如图所示，在T中添加$(u,v)$边，产生环，删除环中不同于$(u,v)$的权值最小的边$(x,y)$，得到T’<br>$$<br>w(T’)=w(T)-w(x,y)+w(u,v)\le w(T)<br>$$<br>与假设中T为最小生成树矛盾</p><p>所以定理1成立</p><img src="http://note.lizhihao999.cn/notes/20200823150547.png" alt="变换" style="zoom:50%;"><h3 id="优化子结构"><a href="#优化子结构" class="headerlink" title="优化子结构"></a>优化子结构</h3><blockquote><p><strong>定理2</strong></p><p>给定连通无向图$G=(V,E)$和权重函数$w:E\to R$，$(u,v)\in E$是G中权值最小的边。设T是G的包含$(u,v)$的一棵最小生成树，则$T-(u,v)$是$G-(u,v)$的一棵最小生成树。</p></blockquote><p>证明：</p><p>由于$T-(u,v)$是不含回路的连通图且包含了$G-(u,v)$的所有顶点，因此，$T-(u,v)$是$G-(u,v)$的一棵生成树。</p><p>假设$T-(u,v)$不是$G-(u,v)$生成代价最小的一棵生成树，则存在$G-(u,v)$的生成树T’，使得$w(T’)&lt;w(T-(u,v))$。</p><p>其中，T’包含顶点$G-(u,v)$且是连通的，因此$T’’=T’+(u,v)$包含G的所有顶点且不含回路，所以T’’是G的一棵生成树<br>$$<br>w(T’’)=w(T’)+w(u,v)&lt;w(T-(u,v))+w(u,v)=w(T)<br>$$<br>与T是G的最小生成树的假设矛盾，所以定理2成立。</p><h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p>也称“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中， 算法从某一顶点开始，逐渐长大直到覆盖整个连通网的所有顶点。</p><p>连通图G和最小生成树的根结点r将作为算法的输入。算法执行过程中，所有不在树A中的结点都存放在一个基于<code>key</code>属性的<strong>最小优先队列Q</strong>中，对于每个结点v，属性<code>v.key</code>保存的是连接v和树中结点的所有边中最小边的权重，如果不存在这样的边，则<code>v.key=∞</code>。属性<code>v.Π</code>给出的是结点v在树中的父节点。Prim算法将GENERIC-MST中的集合A维持在<br>$$<br>A={(v,v.\pi):v\in V-{r}-Q}<br>$$<br>的状态下。</p><p>当Prim算法终止时，最小优先队列Q将为空，而G的最小生成树A则是：<br>$$<br>A={(v,v.\pi):v\in V-{r}}<br>$$</p><pre class="line-numbers language-c"><code class="language-c">MST<span class="token operator">-</span><span class="token function">PRIM</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>w<span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token keyword">for</span> each u∈G<span class="token punctuation">.</span>V        u<span class="token punctuation">:</span>key<span class="token operator">=</span>∞        u<span class="token punctuation">:</span>Π<span class="token operator">=</span>NIL    r<span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token number">0</span>    Q<span class="token operator">=</span>G<span class="token punctuation">.</span>V    <span class="token keyword">while</span> Q≠Ø        u<span class="token operator">=</span>EXTRACT<span class="token operator">-</span><span class="token function">MIN</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span>        <span class="token keyword">for</span> each v∈D<span class="token punctuation">.</span>Adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span>        <span class="token keyword">if</span> v∈Q and <span class="token function">w</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">&lt;</span>v<span class="token punctuation">.</span>key            v<span class="token punctuation">.</span>Π<span class="token operator">=</span>u            v<span class="token punctuation">.</span>key<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>2~6行将每个结点的<code>key</code>值设置为∞（除根结点r外，根结点r的<code>key</code>值设置为0，以便使该结点成为第一个被处理的结点），将每个结点的父节点设置为<code>NIL</code>，并对最小优先队列Q进行初始化，使其包含图中所有结点。</p></li><li><p>7~12行的每遍循环之前：</p><ol><li>$A={(v,v.\pi):v\in V-{v}-Q}$</li><li>已经加入到最小生成树的结点为集合$V-Q$</li><li>对于所有的结点$v\in Q$，如果$v.\pi\ne NIL$，则$v.key&lt;∞$并且$v.key$是连接结点v和最小生成树中某个结点的边$(v,v.\pi)$的权重</li></ol><p>算法第8行将找出结点$u\in Q$，该结点是某条横跨切割$(V-Q,Q)$的轻量级边的一个端点（第1次循环时例外，此时因为算法第5行，所以有u=r）。接着将结点u从队列Q中删除，并将其加入到集合V-Q中，也就是将边$(u,u.\pi)$加入到集合A中。</p><p>9~12行的for循环将每个与u邻接但不在树中的结点v的key和Π值进行更新，从而维持循环不变式的第3部分成立。</p></li></ol><p><img src="http://note.lizhihao999.cn/notes/20200823172032.png" alt="《算法导论》示例"></p><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>Prim算法的运行时间取决于最小优先队列Q的实现方式。</p><ol><li><strong>while循环</strong>：一共执行$|V|$次</li><li><strong>EXTRACT-MIN操作：</strong>单次操作$O(\lg{V})$，总时间为$O(V\lg{V})$</li><li><strong>for循环：</strong>$O(E)$</li></ol><p>总时间代价为：<br>$$<br>O(V\lg{V}+E\lg{V})=O(E\lg{V})<br>$$<br>从渐进意义上来说，Prim算法与Kruskal算法的运行时间相同。</p><h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><h3 id="贪心选择性-1"><a href="#贪心选择性-1" class="headerlink" title="贪心选择性"></a>贪心选择性</h3><blockquote><p><strong>定理3</strong></p><p>设$(u,v)$是G中与顶点u关联的权值最小的边，则必有一棵最小生成树包含边$(u,v)$</p></blockquote><p>证明：</p><p>设T是G的一棵最小生成树，若$(u,v)\in T$，结论成立；</p><p>否则，如图所示，在T中添加$(u,v)$边，产生环，环中顶点u的度为2，即存在$(u,v’)\in T$，删除环中的边$(u,v’)$得到T’<br>$$<br>w(T’)=w(T)-w(u,v’)+w(u,v)\le w(T)<br>$$<br>与T为最小生成树的假设矛盾，所以定理3成立。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>与Kruskal算法最优子结构的证明相同。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼编码</title>
      <link href="/2020/05/05/ha-fu-man-bian-ma/"/>
      <url>/2020/05/05/ha-fu-man-bian-ma/</url>
      
        <content type="html"><![CDATA[<p>哈夫曼编码可以很有效地压缩数据，通常可以节省20%-90%的空间，具体压缩率依赖于数据的特性。我们将带压缩数据看作字符序列，根据每个字符的出现频率，哈夫曼贪心算法构造出字符串的最优二进制表示。</p><blockquote><p><strong>变长编码</strong></p><p>变长编码可以达到比定长编码好得多的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。</p><p><strong>前缀码</strong></p><p>即没有任何码字是其他码字的前缀。前缀码的作用是简化解码过程。</p></blockquote><p>解码过程需要前缀码的一种方便的表示方式，以便我们可以容易地截取开始码字。一种二叉树表示可以满足这种要求，其叶节点为给定的字符。字符的二进制码字用从根节点</p><p>到该字符节点的简单路径表示。其中<strong>“0”表示转向“左孩子”，“1”表示转向“右孩子”</strong>。</p><p>文件的最优编码方案总是对应一棵<strong>满二叉树</strong>，即每个非叶节点都有两个孩子节点。所以，若C为字母表且所有字符的出现频率均为正数，则最优前缀码对应的树恰有$|C|$个叶节点，每个叶节点对应字母表中的一个字符，且恰有$|C|-1$个内部节点。</p><p>给定一棵对应前缀码的树T，可以轻易计算出编码一个文件需要多少个二进制位。对于字母表C中的每个字符c，令属性<code>c.freq</code>表示c在文件中出现的频率， 令$d_T(c)$（$d_T(c)$也是字符c的码字长度）表示c的叶节点在树中的深度。则编码文件需要：<br>$$<br>B(T)=\sum_{c\in C}{c.freq*d_{T}(c)}<br>$$<br>个二进制位，将$B(T)$定义为<strong>T的代价</strong>。</p><h1 id="构建哈夫曼编码"><a href="#构建哈夫曼编码" class="headerlink" title="构建哈夫曼编码"></a>构建哈夫曼编码</h1><p>假定C是一个n个字符的集合，其中每个字符$c\in C$都是一个对象，其属性<code>c.freq</code>给出字符的出现频率。算法自底向上地构造出对应最优编码地二叉树T。从$|C|$个叶节点开始，执行$|C|-1$个<strong>合并</strong>操作，创建出最终的二叉树。算法使用一个以$freq$为关键字的最小优先队列Q，以识别两个最低频率的对象将其合并。当合并两个对象时，得到的新对象的频率设置为原来两个对象的频率之和。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">HUFFMAN</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span>n <span class="token operator">=</span> <span class="token operator">|</span>C<span class="token operator">|</span>Q <span class="token operator">=</span> C<span class="token keyword">for</span> i<span class="token operator">=</span><span class="token number">1</span> to n<span class="token number">-1</span>    allocate a new node z    z<span class="token punctuation">.</span>left <span class="token operator">=</span> x <span class="token operator">=</span> EXTRACT<span class="token operator">-</span><span class="token function">MIN</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span>    z<span class="token punctuation">.</span>right <span class="token operator">=</span> y <span class="token operator">=</span> EXTRACT<span class="token operator">-</span><span class="token function">MIN</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span>    z<span class="token punctuation">.</span>freq <span class="token operator">=</span> x<span class="token punctuation">.</span>freq <span class="token operator">+</span> y<span class="token punctuation">.</span>freq    <span class="token function">INSERT</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token keyword">return</span> EXTRACT<span class="token operator">-</span><span class="token function">MIN</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.lizhihao999.cn/notes/20200822164521.png" alt="算法过程——《算法导论》"></p><h1 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h1><p>为了证明贪心HUFFMAN算法正确，需要证明确定最优前缀码的问题具有贪心选择和最优子结构性质。</p><h2 id="1-贪心选择性质"><a href="#1-贪心选择性质" class="headerlink" title="1. 贪心选择性质"></a>1. 贪心选择性质</h2><blockquote><p><strong>引理1</strong></p><p>令C为一个字母表，其中每个字符$c\in C$都有一个频率<code>c.freq</code>。令x和y是C中频率最低的两个字符。那么存在C的一个最优前缀码，x和y的码字长度相同，且只有最后一个二进制位不同。</p></blockquote><p>证明思路：令T表示任意一个最优前缀码所对应的编码树（最优前缀码编码树不唯一），对其进行修改，得到表示另外一个最优前缀码的编码树，使得在新树种，x和y是深度最大的兄弟叶结点。这样构造出的树，x和y的码字长度相同，且只有最后一位不同。</p><p>证明：</p><p>令a，b是T中深度最大的兄弟叶结点。不失一般性，假定$a.freq\le b.freq,\quad x.freq\le y.freq$。又因为x，y的频率最低，所以$a.freq\ge x.freq,\quad b.freq\ge y.freq$</p><p>存在可能性，$x.freq=a.freq或y.freq=b.freq$；如果$x.freq=b.freq$，则$x.freq=b.freq=a.freq=y.freq$，此时引理显然成立；故假设$x.freq\ne b.freq$，也即$a.freq=b.freq和a.freq=x.freq$不同时成立。</p><p>在T中交换x和a得到一棵新树T‘，在T’中交换y和b得到新树T”，则在T”中x和y是深度最深的两个兄弟节点。计算T和T’的代价差：</p><p>$B(T)-B(T’)=\sum_{c\in C}{c.freq\cdot d_{T}(c)}-\sum_{c\in C}{c.freq\cdot d_{T’}(c)}$</p><p>​                                   $=[x.freq\cdot d_{T}(x)+a.freq\cdot d_{T}(a)]-[x.freq\cdot d_{T’}(x)+a.freq\cdot d_{T’}(a)]$</p><p>​                                   $=[x.freq\cdot d_{T}(x)+a.freq\cdot d_{T}(a)]-[x.freq\cdot d_{T}(a)+a.freq\cdot d_{T}(x)]$    <strong>(x在T’中的位置就是a在T中的位置)</strong></p><p>​                                   $=[x.freq\cdot d_{T}(x)-a.freq\cdot d_{T}(x)]-[x.freq\cdot d_{T}(a)-a.freq\cdot d_{T}(a)]$</p><p>​                                   $=(a.freq-x.freq)(d_{T}(a)-d_{T}(x))$</p><p>​                                   $\ge 0$    ($a.freq-x.freq和d_{T}(a)-d_{T}(x)$都非负)</p><p>类似，$B(T’)-B(T’’)\ge 0$，又因为<strong>T是最优的</strong>，所以$B(T)=B(T’)=B(T’’)$，即<strong>T’’也是最优的</strong>，引理成立。</p><p><img src="http://note.lizhihao999.cn/notes/20200822175055.png" alt="《算法导论》图例说明"></p><p>引理1说明，不失一般性，通过合并来构造最优树的过程，可以从合并出现频率最低的两个字符的贪心选择开始。</p><h2 id="2-最优子结构性质"><a href="#2-最优子结构性质" class="headerlink" title="2. 最优子结构性质"></a>2. 最优子结构性质</h2><blockquote><p><strong>引理2</strong></p><p>令C为一个给定的字母表，其中每个字符$c\in C$都定义了一个频率<code>c.freq</code>。令x和y是C中频率最低的两个字符。令C’为C去掉字符x和y，加入一个新字符z后得到的字母表，即$C’=C-{x,y}\bigcup{z}$。类似C，也为C’定义<code>freq</code>，不同之处只是<code>z.freq=x.freq+y.freq</code>。令T’为字母表C’的任意一个最优前缀码对应的编码树。将T’中叶结点z替换为一个以x和y为孩子的内部节点，得到树T，T表示字母表C的一个最优前缀码。</p></blockquote><p>证明：</p><p>首先表示:<br>$$<br>B(T’)=B(T)-x.freq-y.freq<br>$$<br>使用反证法进行证明。假定T对应的前缀码并不是C的最优前缀码。存在最优编码树T’’满足$B(T’’)&lt;B(T)$。不失一般性（引理1），T’’包含兄弟节点x和y。令T’’’为将T’’中x、y及他们的父节点替换为叶结点z得到的树，其中<code>z.freq=x.freq+y.freq</code>。于是<br>$$<br>B(T’’’)=B(T’’)-x.freq-y.freq&lt;B(T)-x.freq-y.freq=B(T’)<br>$$<br>与T’对应C’的一个最优前缀码的假设矛盾。因此，T必然表示字母表C的一个最优前缀码。</p><h2 id="3-最优性质"><a href="#3-最优性质" class="headerlink" title="3. 最优性质"></a>3. 最优性质</h2><blockquote><p><strong>定理1</strong></p><p>过程HUFFMAN会生成一个最优前缀码。</p></blockquote><p>证明： 由引理1、2可得到。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活动选择问题</title>
      <link href="/2020/05/04/huo-dong-xuan-ze-wen-ti/"/>
      <url>/2020/05/04/huo-dong-xuan-ze-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有一个n个活动的集合，$S={a_1,a_2,…,a_n}$，这些活动使用同一个资源（一个教室），而这个资源在某个时刻只能供一个活动使用。</p><p>每个活动都有一个$开始时间s_i$和一个$结束时间f_i$，其中$0\le s_i&lt;f_i&lt;\infin$。如果被选中。任务$a_i$发生在半开时间区间$[s_i,f_i)$期间。</p><p>如果两个活动$a_i$和$a_j$满足$[s_i,f_i)$和$[s_j,f_j)$不重叠，则称它们是<strong>兼容的</strong>。</p><p>在<strong>活动选择问题</strong>中，我们希望选出一个<strong>最大兼容活动集</strong>。</p><h1 id="问题假设"><a href="#问题假设" class="headerlink" title="问题假设"></a>问题假设</h1><p>活动已经按<strong>结束时间的单调递增顺序</strong>排序：<br>$$<br>f_1\le f_2\le f_3\le …\le f_{n-1}\le f_n<br>$$</p><h1 id="设计算法"><a href="#设计算法" class="headerlink" title="设计算法"></a>设计算法</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><ul><li>$S_{ij}$：在$a_i$活动结束之后，且在$a_j$开始之前结束的所有活动的集合</li><li>$A_{ij}$：$S_{ij} $的最大相互兼容的活动子集</li></ul><p>设$A_{ij}$包含活动$a_k$，$S_{ij}$中最大兼容任务子集</p><ul><li>$A_{ij}$包含$|A_{ij}|=|A_{ik}|+|A_{kj}|+1$个活动</li><li>$A_{ij}=A_{ik}\bigcup{a_k}\bigcup A_{kj}$</li></ul><h2 id="贪心选择"><a href="#贪心选择" class="headerlink" title="贪心选择"></a>贪心选择</h2><ul><li><p><strong>选择所有可选活动中，最早结束的活动</strong></p><p><strong>证明：</strong><br>$$<br>考虑任意非空子问题S_k，令a_m是S_k种结束时间最早的活动，则a_m在S_k的某个最大兼容活动子集中<br>$$<br>令$A_k$是$S_k$的一个最大兼容活动子集，且$a_m$是$A_k$中结束时间最早的活动。</p><ul><li><p>若$a_j=a_m$，则已经证明$a_m$在$S_k$的某个最大兼容活动子集中</p></li><li><p>若$a_j\ne a_m$，令集合$A’_k=A_k-{a_j}\bigcup{a_m}$，即：将$A_k$中的$a_j$替换为$a_m$。</p><p>$\because A_k$中的活动都是不相交的，$a_j$是$A_k$中结束时间最早的活动，并且$f_m\le f_j$</p><p>$\therefore A’_{k}$中的活动都是不相交的</p><p>$\because |A’_k|=|A_k|$</p><p>$\therefore A’_k$也是$S_k$的一个最大兼容活动子集</p></li></ul></li><li><p>选择所有可选活动中，最晚开始的活动</p><p><strong>证明</strong>：<br>$$<br>考虑任意非空子问题S_k，令a_m是S_k种开始时间最晚的活动，则a_m在S_k的某个最大兼容活动子集中<br>$$<br>令$A_k$是$S_k$的一个最大兼容活动子集，且$a_m$是$A_k$中开始时间最晚的活动。</p><ul><li><p>若$a_j=a_m$，则已经证明$a_m$在$S_k$的某个最大兼容活动子集中</p></li><li><p>若$a_j\ne a_m$，令集合$A’_k=A_k-{a_j}\bigcup{a_m}$，即：将$A_k$中的$a_j$替换为$a_m$。</p><p>$\because A_k$中的活动都是不相交的，$a_j$是$A_k$中开始时间最晚的活动，并且$s_m\ge s_j$</p><p>$\therefore A’_{k}$中的活动都是不相交的</p><p>$\because |A’_k|=|A_k|$</p><p>$\therefore A’_k$也是$S_k$的一个最大兼容活动子集</p></li></ul></li></ul><h2 id="递归贪心算法"><a href="#递归贪心算法" class="headerlink" title="递归贪心算法"></a>递归贪心算法</h2><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n)    m = k+1    while m<=n and s[m]<f[k] do        m = m+1        if m <= n do            return &#123;a[m]&#125; and RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)        else             return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代贪心算法"><a href="#迭代贪心算法" class="headerlink" title="迭代贪心算法"></a>迭代贪心算法</h2><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">GREEDY-ACTIVITY-SELECTOR(s,f)    n = s.length    A=&#123;a[1]&#125;    k=1    for m=2 to n do        if s[m]>=f[k] do            A.append&#123;a[m]&#125;            k = m    return A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2020/05/03/tan-xin-suan-fa/"/>
      <url>/2020/05/03/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出在当时看来最佳的选择。这种启发式策略不能保证总能找到最优解，但对某些问题确实能够得到最优解。</p><h1 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h1><ol><li><p>转换最优化问题形式：对其做出一次选择后，只剩下一个子问题需要求解</p></li><li><p>证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的</p></li><li><p>证明做出贪心选择后，剩余的子问题，满足性质：其最优解与贪心选择组合即可得到原问题的最优解</p></li></ol><h1 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h1><p><strong>我们可以通过做出局部最优选择来构造全局最优解</strong>，即直接做出在当前问题看来最优的选择，不必考虑子问题的解。</p><h1 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h1><p>当应用贪心算法时，我们只需要论证：将子问题的最优解与贪心选择组合在一起就可以得到原问题的最优解。这种方法隐含地对子问题使用了数学归纳法，证明了在每个步骤进行贪心选择都会生成原问题地最优解。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/2020/05/02/zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2020/05/02/zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h1><ul><li><p><strong>子序列</strong><br>$$<br>对于给定序列X=&lt;x_1,x_2,…,x_m&gt;，Z=&lt;z_1,z_2,…z_k&gt;<br>$$<br>$$<br>存在一个严格递增的X的下标序列&lt;i_1,i_2,…,i_k&gt;，对所有j=1,2,…,k<br>$$</p><p>$$<br>满足x_{i_j}=z_j<br>$$</p><p>则称Z为X的子序列</p></li><li><p><strong>公共子序列</strong></p><p>Z既是X的子序列，也是Y的子序列</p></li><li><p><strong>问题描述</strong></p><p>给定两个序列<br>$$<br>X=&lt;x_1,x_2,…,x_m&gt;,Y=&lt;y_1,y_2,…,y_n&gt;<br>$$<br>求X和Y的<strong>长度最长</strong>的公共子序列</p></li></ul><h1 id="应用动态规划算法"><a href="#应用动态规划算法" class="headerlink" title="应用动态规划算法"></a>应用动态规划算法</h1><h2 id="1-刻画最长公共子序列的特征"><a href="#1-刻画最长公共子序列的特征" class="headerlink" title="1. 刻画最长公共子序列的特征"></a>1. 刻画最长公共子序列的特征</h2><h3 id="LCS最优子结构"><a href="#LCS最优子结构" class="headerlink" title="LCS最优子结构"></a>LCS最优子结构</h3><p>令$$X=&lt;x_1,x_2,…,x_m&gt;,Y=&lt;y_1,y_2,…,y_n&gt;$$为两个序列，$$Z=&lt;z_1,z_2,…,z_k&gt;$$是X和Y的任意LCS</p><ul><li>如果$x_m=y_n，则z_k=x_m=y_n且Z_{k-1}是X_{m-1}和Y_{n-1}的一个LCS$</li><li>如果$x_m\ne y_n，那么z_k\ne x_m\implies Z是X_{m-1}和Y的一个LCS$</li><li>如果$x_m\ne y_n，那么z_k\ne y_n\implies Z是X和Y_{n-1}的一个LCS$</li></ul><h2 id="2-一个递归解"><a href="#2-一个递归解" class="headerlink" title="2. 一个递归解"></a>2. 一个递归解</h2><p><img src="http://note.lizhihao999.cn/notes/20200819163534.png" alt="递归解形式"></p><h2 id="3-计算LCS的长度"><a href="#3-计算LCS的长度" class="headerlink" title="3. 计算LCS的长度"></a>3. 计算LCS的长度</h2><pre class="line-numbers language-pseudocode"><code class="language-pseudocode"> LCS-LENGTH(X,Y) m <- X.length n <- Y.lengthlet c[0...m][0...n] be new tablefor i<-1 to m do    c[i,0] <- 0for i<-1 to n do    c[0,j] <- 0for i<-1 to m do    for j<-1 to n do        if X[i]==Y[j] do            c[i][j] <- c[i-1][j-1] + 1        else             c[i][j] <- max&#123;c[i-1][j], c[i][j-1]&#125; return c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-构造LCS"><a href="#4-构造LCS" class="headerlink" title="4. 构造LCS"></a>4. 构造LCS</h2><p>这里没有使用多余的表来存储顺序，而是通过$c[i-1][j],c[i][j-1],c[i-1][j-1]$的大小关系来判断顺序</p><ul><li>如果$c[i][j]==0$，则结束</li><li>如果$c[i-1][j]==c[i][j]$，则对$i=i-1,j=j$继续</li><li>如果$c[i][j-1]==c[i][j]$，则对$i=1,j=j-1$继续</li><li>如果$c[i-1][j-1]+1==c[i][j]$，则对$i=i-1,j=j-1$继续，并输出$X[i]$</li></ul><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">PRINT-LCS(X, c, i, j)if c[i][j] == 0 do    return/* 如果c[i-1][j]==c[i][j]，则对i=i-1,j=j继续 */if c[i-1][j] == c[i][j] do    PRINT-LCS(X, c, i-1, j)/* 如果c[i][j-1]==c[i][j]，则对i=i,j=j-1继续 */else if c[i][j-1] == c[i][j] do    PRINT-LCS（X, c, i, j-1)/* 如果c[i-1][j-1]+1==c[i][j]，则对i=i-1,j=j-1继续 */else    PRINT-LCS(X, c, i-1, j-1)    print(X[i])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">my_max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">>=</span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">lcs_length</span><span class="token punctuation">(</span>string X<span class="token punctuation">,</span> string Y<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> X<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> Y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token function">c</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 注意对应X和Y的索引 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> Y<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">my_max</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print_lcs</span><span class="token punctuation">(</span>string X<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">print_lcs</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">print_lcs</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">print_lcs</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> X<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    string X<span class="token punctuation">;</span>    string Y<span class="token punctuation">;</span>    cin <span class="token operator">>></span> X<span class="token punctuation">;</span>    cin <span class="token operator">>></span> Y<span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> X<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> Y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c <span class="token operator">=</span> <span class="token function">lcs_length</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">print_lcs</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> c<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h1><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>对于计算某个位置的$c[i][j]$只需要三个表项：$c[i-1][j-1],c[i-1][j],c[i][j-1]$，所以其实只需要当前一行和上一行的表项数值，故利用利用一个二维数组记录当前行和上一行的数值即可</p><table><thead><tr><th align="center">$c[i-1][j-1]$</th><th align="center">$c[i-1][j] $</th></tr></thead><tbody><tr><td align="center">$c[i][j-1]$</td><td align="center">$c[i][j] $</td></tr></tbody></table><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">/* 假设X长度m<=Y长度n */LCS-LENGTH(X, Y)m <- X.lengthn <- Y.lengthlet c[2][m] be new tablefor i<-1 to n do    for j<-1 to m do        if X[j] == Y[i] do            c[(i+1)%2][j] <- c[i%2][j-1]+1        else            c[(i+1)%2][j] <- max&#123;c[(i+1)%2][j-1], c[i%2][j]&#125;return c[n%2][m]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">lcs_pro</span><span class="token punctuation">(</span>string X<span class="token punctuation">,</span> string Y<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> X<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> Y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>X<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> Y<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                c<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                c<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">my_max</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>对于计算某个位置的$c[i][j]$需要三个表项：<br>$$<br>c[i-1][j-1],c[i-1][j],c[i][j-1]<br>$$<br>如果在一行中表示，对于某个待计算的$c[j]$其中：<br>$$<br>c[i-1][j]=未覆盖前的c[j]<br>$$<br>$$<br>c[i][j-1]=c[j]<br>$$</p><p>$$<br>c[i-1][j-1]=覆盖之前的c[j-1]<br>$$</p><p>所以在一行中$c[i-1][j]和c[i]][j-1]$已经存在，只需要额外一个空间保存被覆盖的$c[i-1][j-1]$即可</p><table><thead><tr><th align="center">被覆盖$c[i-1,j-1]=pre$</th><th align="center"></th></tr></thead><tbody><tr><td align="center">$c[i][j-1]=c[j-1]$</td><td align="center">$c[i-1][j]=c[j]$</td></tr><tr><td align="center"></td><td align="center"><strong>待写入</strong>$c[i,j]$</td></tr></tbody></table><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">/* 假设X长度m<=Y长度n */LCS-LENGTH(X, Y)m <- X.lengthn <- Y.lengthlet c[m] be new table/* pre记录被前一个覆盖的值 */pre <- 0for i<-1 to n do    for j<-1 to m do        /* tmp临时记录被覆盖的值 */        tmp <- c[j]        if X[j] == Y[i] do            c[j] = pre+1        else            c[j] = max&#123;c[j], c[j-1]&#125;        pre <- tmpreturn c[m]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-c++"><code class="language-c++">int lcs_plus(string X, string Y)&#123;    int m = X.size();    int n = Y.size();    int pre = 0;    vector<int> c(m + 1);    for (int i = 1; i <= n; i++) &#123;        for (int j = 1; j <= m; j++) &#123;            int tmp = c[j];            if (X[j - 1] == Y[i - 1]) &#123;                c[j] = pre + 1;            &#125;            else &#123;                c[j] = my_max(c[j - 1], c[j]);            &#125;            pre = tmp;        &#125;    &#125;    return c[m];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵链乘法</title>
      <link href="/2020/05/01/ju-zhen-lian-cheng-fa/"/>
      <url>/2020/05/01/ju-zhen-lian-cheng-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定n个矩阵的链$&lt;A_1,A_2,…,A_n&gt;$，矩阵$A_i$的规模为$p_{i-1}\times p_{i}(1\le i\le n)$，求完全括号化方案，使得计算乘积$A_1A_2…A_n$所需标量乘法次数最少</p><ul><li><p><strong>完全括号化</strong></p><p>单一矩阵或者两个完全括号化的矩阵乘积链的积，且已外加括号</p><ul><li>例：$（A_1(A_2)(A_3A_4)）$</li></ul></li></ul><h1 id="应用动态规划方法"><a href="#应用动态规划方法" class="headerlink" title="应用动态规划方法"></a>应用动态规划方法</h1><h2 id="1-最优括号化方案的结构特征"><a href="#1-最优括号化方案的结构特征" class="headerlink" title="1. 最优括号化方案的结构特征"></a>1. 最优括号化方案的结构特征</h2><ul><li><p>假设$A_iA_{i+1}…A_j$的最优括号化方案的分割点在$A_k$和$A_{k+1}$之间</p></li><li><p>将问题划分为两个子问题（$A_iA_{i+1}…A_k$和$A_{k+1}A_{k+2}…A_j$的最优化括号问题），求出子问实例的最优解，然后将子问题的最优解组合起来</p></li><li><p>需要在分割点的时候考察完<strong>所有可能的划分点</strong>，保证不会遗漏最优解</p></li></ul><h2 id="2-一个递归求解方案"><a href="#2-一个递归求解方案" class="headerlink" title="2. 一个递归求解方案"></a>2. 一个递归求解方案</h2><ul><li><p>对所有$1\le i\le j\le n$确定$A_iA_{i+1}…A_j$的最小代价括号方案作为子问题</p></li><li><p>$m[i,j]$表示计算矩阵$A_{i…j}$所需标量乘法次数的最小值</p></li><li><p>计算$A_{1…n}$所需的最低代价为$m[1,n]$</p></li><li><p>递归定义$m[i,j]$：</p><ul><li><p>平凡问题：$i=j$的平凡问题，矩阵链只包含唯一的矩阵$A_{i,i}=A_i$，不需要多余计算</p><p>$\implies$所有$i=1,2…,n,\quad m[i,i]=0$</p></li><li><p>$i&lt;j$：利用<strong>最优子结构</strong>计算$m[i,j]$<br>$$<br>m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_kp_j<br>$$</p></li><li><p>假设最优分割点k已知，可能取值有$j-i$种，$k=i,i+1,…,j-1$，遍历所有情况找到最优值<br>$$<br>m[i,j]=\begin{cases}<br>0\quad i=j\<br>\min_{i\le k&lt;j}{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j}\quad i&lt;j<br>\end{cases}<br>$$</p></li></ul></li><li><p>$s[i,j]$保存$A_iA_{i+1}…A_j$最优括号化方案的分割点位置k<br>$$<br>m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j}成立的k值<br>$$</p></li></ul><h2 id="3-计算最优代价"><a href="#3-计算最优代价" class="headerlink" title="3. 计算最优代价"></a>3. 计算最优代价</h2><ul><li><p>首先计算所有$m[i,i]=0\quad i=1,2…,n$</p></li><li><p>以此计算链长度$l+1$的$m[i,j]$，仅依赖于$m[i,k],m[k+1,j]$</p></li><li><p>按<strong>对角线</strong>顺序进行计算</p><p><img src="http://note.lizhihao999.cn/notes/20200819160530.png" alt="计算顺序"></p></li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">MATRIX-CHAIN-ORDER(p)n = p.length-1let m[1..n,1..n]and s[1..n-1,2..n] be new tablesfor i = 1 to n    m[i,i] = 0for l = 2 to n    for i = 1 to n-l+1        j = i+l-1        m[i,j] = ∞        for k = i to j-1            q = m[i,k]+m[k+1,j]+p_&#123;i-1&#125;p_&#123;k&#125;p_&#123;j&#125;            if q < m[i,j]                m[i,j] = q                s[i,j] = kreturn m and s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-构造最优解"><a href="#4-构造最优解" class="headerlink" title="4. 构造最优解"></a>4. 构造最优解</h2><ul><li>$s[1..n-1,2..n]$记录了构造最优解所需的信息<ul><li>$s[i,j]$记录一个k值，指出$A_iA_{i+1}…A_j$的最优括号化方案的分割点位置</li><li>$s[1,s[1,n]]$指出计算$A_{1..s[1,n]}$时进行的最后一次运算</li><li>$s[s[1,n]+1,n]$指出计算$A_{s[1,n]+1..n}$时应进行的最后一次运算</li></ul></li><li>递归可输出最优括号法方案</li></ul><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">PRINT-OPTIMAT-PARENS(s,i,j)if i==j    print("A")else    print("(")    PRINT-OPTIMAT_PARENS(s,i,s[i,j])    PRINT_OPTIMAT_PARENS(s,s[i,j]+1,j)    print(")")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2020/04/30/dong-tai-gui-hua/"/>
      <url>/2020/04/30/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Those who cannot remember the past are condemned to repeat it.</strong></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>动态规划同常用来求解<strong>最优化问题</strong>。这类问题通常有很多可行解，每个解都有一个值，我们希望寻找最优值的解。</p><h2 id="动态规划与分治算法"><a href="#动态规划与分治算法" class="headerlink" title="动态规划与分治算法"></a>动态规划与分治算法</h2><p>动态规划与分治算法有相似与不同之处，相似之处为都通过组合子问题的解来求解原问题。不同之处为动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。这种情况下，分治算法会做很多重复的工作（重复求子问题的解），而动态规划对每个子问题只求解一次，将结果保存在表格当中，避免不必要的计算工作。</p><table><thead><tr><th align="center"></th><th align="center">分治法</th><th align="center">动态规划</th></tr></thead><tbody><tr><td align="center">算法思想</td><td align="center">组合子问题</td><td align="center">组合子问题</td></tr><tr><td align="center">计算方式</td><td align="center">自顶向下</td><td align="center">自底向上</td></tr><tr><td align="center">相同要素</td><td align="center">具有最优子结构</td><td align="center">具有最优子结构</td></tr><tr><td align="center">不同要素</td><td align="center">不包含公共子问题（独立）</td><td align="center">重叠子问题</td></tr></tbody></table><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>保存已求解子问题的解</strong></p></li><li><p><strong>将原始问题划分为一系列子问题</strong></p></li><li><p><strong>自底向上计算</strong></p></li></ul><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><ul><li><h4 id="给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解"><a href="#给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解" class="headerlink" title="给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解"></a>给定一组约束条件和一个代价函数，在解空间中搜索具有最小或最大代价的优化解</h4></li><li><h4 id="很多优化问题可分为多个子问题，子问题相互关联，子问题的解被重复使用"><a href="#很多优化问题可分为多个子问题，子问题相互关联，子问题的解被重复使用" class="headerlink" title="很多优化问题可分为多个子问题，子问题相互关联，子问题的解被重复使用"></a>很多优化问题可分为多个子问题，子问题相互关联，子问题的解被重复使用</h4></li></ul><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><h4 id="优化子结构"><a href="#优化子结构" class="headerlink" title="优化子结构"></a>优化子结构</h4><ul><li><strong>一个问题的优化解包含了子问题的优化解</strong></li></ul></li><li><h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><ul><li><strong>在问题的求解过程中，很多子问题的解将被多次使用</strong></li></ul></li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li><h4 id="刻画一个最优解的结构特征"><a href="#刻画一个最优解的结构特征" class="headerlink" title="刻画一个最优解的结构特征"></a>刻画一个最优解的结构特征</h4><p>寻找最优子结构，利用这种子结构从子问题的最优解构造出原问题的最优解</p></li><li><h4 id="递归定义最优解的值"><a href="#递归定义最优解的值" class="headerlink" title="递归定义最优解的值"></a>递归定义最优解的值</h4></li><li><h4 id="自底向上计算最优解的值"><a href="#自底向上计算最优解的值" class="headerlink" title="自底向上计算最优解的值"></a>自底向上计算最优解的值</h4></li><li><h4 id="根据构造最优解的信息构造优化解"><a href="#根据构造最优解的信息构造优化解" class="headerlink" title="根据构造最优解的信息构造优化解"></a>根据构造最优解的信息构造优化解</h4></li></ul><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul><li><h4 id="带备忘的自顶向下法"><a href="#带备忘的自顶向下法" class="headerlink" title="带备忘的自顶向下法"></a>带备忘的自顶向下法</h4><ul><li>递归求解</li><li>保存每个子问题的解（数组或散列表）</li></ul></li><li><h4 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h4><ul><li>恰当定义子问题的<strong>规模</strong></li><li>任何子问题的求解都只依赖于<strong>更小的</strong>子问题的解</li><li>按子问题规模<strong>由小到大进行求解</strong></li><li>第一次求解一个问题时，它的所有前提子问题都已求解完成且<strong>保存结果</strong></li></ul></li></ul><p>两种方法的算法的<strong>渐进运行时间相同</strong>，<strong>自底向上的时间复杂性</strong>函数通常具有更小的系数，某些情况下自顶向下无法真正递归考察所有可能的子问题。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><ul><li><p><strong>发掘最优子结构的通用模式</strong></p><ol><li>证明问题最优解的第一个组成部分是做出一个选择，做出这次选择会产生一个或多个待解的子问题</li><li>对于一个给定问题，在其可能的第一步选择中，你<strong>假定已经知道</strong>哪种选择才会得到最优解。并<strong>不关心如何得到，只是假定已经知道</strong></li><li>给定可获得最优解的选择后，你确定这次选择会产生哪些<strong>子问题</strong>，以及如何<strong>最好地刻画子问题空间</strong></li></ol></li><li><p><strong>保持子问题空间尽可能简单，只在必要时才扩展它</strong></p></li><li><p><strong>不同问题领域，最优子结构的不同</strong>：</p><ul><li>原问题的最优解中涉及多少个子问题</li><li>再确定最优解使用哪些子问题时，我们需要考虑多少种选择</li></ul></li><li><p><strong>粗略分析算法的运行时间：</strong><br>$$<br>O(m\times n)<br>$$</p></li></ul><p>$$<br>\Theta(n):子问题个数\quad\quad m:考察的选择个数<br>$$</p><h2 id="重叠子问题-1"><a href="#重叠子问题-1" class="headerlink" title="重叠子问题"></a>重叠子问题</h2><p>如果递归算法反复求解相同的子问题，则称最优化问题具有<strong>重叠子问题</strong>。一般来讲， 不同子问题的总数最好是输入规模的多项式函数。</p><h2 id="重构最优解"><a href="#重构最优解" class="headerlink" title="重构最优解"></a>重构最优解</h2><p><strong>将每个子问题所做的选择存在一个表中</strong>：重构每次选择只需$O(1)$时间</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>维护一个表记录子问题的解，保持递归算法的控制流程：</p><ul><li>每个表项的初值设为一个特殊值，表示尚未填入子问题的解</li><li>当递归调用过程中第一次遇到子问题时，计算其解，并存入对应表项</li><li>每次遇到同一个子问题，查表返回解</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li><strong>通常情况</strong>：每个子问题必须至少求解一次<ul><li>自底向上动态规划算法比自顶向下备忘算法快（都是$O(n^3)$，相差常量系数）</li><li>自底向上算法没有递归调用的开销，表的维护开销更小</li></ul></li><li><strong>某些问题：</strong>可利用表的访问模式进一步降低时空代价</li><li><strong>某些子问题完全不必求解：</strong>备忘方法更有优势（只求解必要子问题）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2020/04/28/kuai-su-pai-xu/"/>
      <url>/2020/04/28/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<p><strong>快速排序能够实现原址排序，而且平均性能很好。最基本的快速排序基于分治思想。</strong></p><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><ol><li><p>选定分界值，将原数组划分为两个部分</p></li><li><p>左边的值都小于分界值，右边的值都大于等于分界值</p></li><li><p>对左右两侧数组再次进行1、2步骤</p></li><li><p>直到所有数据排序完成</p></li></ol><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">QUICKSORT(A,low,high)if low < high    q = PARTITION(A,low,high)    QUICKSORT(A,low,q-1)    QUICKSORT(A,q+1,high)PRTITION(A,low,high)x = A[high]i = low-1for j=low -> high-1    if A[j] <= x        i++        exchange A[i] with A[j]exchange A[i+1] with A[high]return i+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="划分-PARTITION"><a href="#划分-PARTITION" class="headerlink" title="划分(PARTITION)"></a>划分(PARTITION)</h1><ul><li><p>选定一个分界值x（此例中为数组最后一个元素）</p></li><li><p>整个数组分为三个部分：</p><ul><li><p>小于x的部分</p></li><li><p>大于等于x的部分</p></li><li><p>未确定的部分</p><p><img src="http://note.lizhihao999.cn/notes/20200819111943.png" alt="排序过程中的四个部分"></p></li></ul></li><li><p>循环开始时<code>i=low-1</code>,<code>j=low</code></p></li><li><p>考虑当前<code>A[j]</code>与分界值<code>x</code>的大小关系</p><ul><li>如果<code>A[j]</code>小于<code>x</code>，则<code>i++</code>，同时交换<code>A[i]</code>和<code>A[j]</code>$\implies$保证<code>i</code>之前为小于<code>x</code>的值</li><li>否则<code>j++</code>，继续遍历</li></ul></li><li><p>最后交换<code>A[i+1]</code>和<code>x</code></p><p><img src="http://note.lizhihao999.cn/notes/20200819114038.png" alt="划分过程中的两种情况"></p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>使用最基本的快速排序对$&lt;13,19,9,5,12,4,7,8&gt;$进行一次划分</p><img src="http://note.lizhihao999.cn/notes/20200819111516.png" style="zoom:50%;"><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quicksort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quicksort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="随机化版本"><a href="#随机化版本" class="headerlink" title="随机化版本"></a>随机化版本</h2><p>输入的数组的元素分布不一定是均衡的，采用<strong>随机取样</strong>的方法期望在平均情况下划分是比较均衡的，即随机选取主元元素。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机选择一个分界值</span><span class="token keyword">int</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> len <span class="token operator">+</span> low<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">random_partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将分界值交换到最后一位</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">random_quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token function">random_partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">random_quicksort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">random_quicksort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="快速排序的性能"><a href="#快速排序的性能" class="headerlink" title="快速排序的性能"></a>快速排序的性能</h1><p>快速排序的运行时间依赖于<strong>划分是否平衡</strong>，平衡与否依赖于<strong>划分的元素</strong>。</p><h2 id="划分的复杂度"><a href="#划分的复杂度" class="headerlink" title="划分的复杂度"></a>划分的复杂度</h2><p>$$<br>T(n)=\Theta(n)<br>$$</p><p>$$<br>n=high-low+1<br>$$</p><h2 id="最坏情况的划分"><a href="#最坏情况的划分" class="headerlink" title="最坏情况的划分"></a>最坏情况的划分</h2><p>当划分产生的两个子问题分别包含<code>n-1</code>个元素和<code>0</code>个元素时，快速排序的最坏情况发生。不妨假设算法的每一次递归调用中都出现这种不平衡划分，其中划分操作的时间复杂度为$\Theta(n)$。由于，对一个大小为0的数组进行递归调用会直接返回，因此$T(0)=\Theta(1)$，于是算法运行时间的递归式可以表示为：<br>$$<br>T(n)=T(n-1)+T(0)+\Theta(n)=T(n-1)+\Theta(n)<br>$$<br>利用代入法证明：</p><p><strong>猜想假设</strong>：$T(n)=O(n^2)\quad c&gt;0$</p><ol><li>首先归纳假设：$\exist c &gt; 0,使得T(n)\le cn^2$</li></ol><p>则$T(n-1)\le c(n-1)^2$</p><p>$\implies T(n)\le c(n-1)^2+\Theta(n)$</p><p>$=c(n^2-2n+1)+\Theta(n)$</p><p>$=cn^2-c\times2n+c+\Theta(n)$</p><p>当$-2cn+c+\Theta(n)\le 0$时，</p><p>$T(n)\le cn^2$</p><p>$\therefore T(n)=O(n^2)$</p><ol start="2"><li>归纳假设：$\exist c &gt; 0,使得T(n)\ge cn^2$</li></ol><p>则$T(n-1)\ge c(n-1)^2$</p><p>$\implies T(n)\ge c(n-1)^2+\Theta(n)$</p><p>$=c(n^2-2n+1)+\Theta(n)$</p><p>$=cn^2-c\times2n+c+\Theta(n)$</p><p>当$-2cn+c+\Theta(n) \ge 0$时，</p><p>$T(n)\ge cn^2$</p><p>$\therefore T(n)=\Theta(n^2)$</p><h2 id="最坏运行时间"><a href="#最坏运行时间" class="headerlink" title="最坏运行时间"></a>最坏运行时间</h2><p>在最坏情况下，快速排序的每一层递归的时间复杂度为$\Theta(n^2)$，从直观上来看，这就是最坏情况下的运行时间$\Theta(n^2)$。</p><h2 id="期望运行时间"><a href="#期望运行时间" class="headerlink" title="期望运行时间"></a>期望运行时间</h2><p>随机化快速排序的期望运行时间为$O(n\lg{n})$；如果每一层递归上随机化算法都将任意常数比例的元素划分到一个子数组中，则算法的递归树的深度为$\Theta(\lg{n})$，并且每一层上的工作量都是$O(n)$。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="/2020/04/27/fen-zhi-suan-fa/"/>
      <url>/2020/04/27/fen-zhi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一-分治算法的设计"><a href="#一-分治算法的设计" class="headerlink" title="一. 分治算法的设计"></a>一. 分治算法的设计</h1><ul><li><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>将整个问题划分为多个子问题</p></li><li><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>求解各个子问题</p></li><li><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并子问题的解，形成原始问题的解</p></li></ul><h1 id="二-分治算法的分析"><a href="#二-分治算法的分析" class="headerlink" title="二. 分治算法的分析"></a>二. 分治算法的分析</h1><ul><li><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><ul><li>建立递归方程</li><li>求解</li></ul></li><li><h3 id="递归方程的建立方法"><a href="#递归方程的建立方法" class="headerlink" title="递归方程的建立方法"></a>递归方程的建立方法</h3><ul><li>设输入大小为n,T(n)为时间复杂性</li><li>当$n&lt;c, T(n)=\Theta(1)$</li></ul></li><li><h3 id="划分阶段的时间复杂性"><a href="#划分阶段的时间复杂性" class="headerlink" title="划分阶段的时间复杂性"></a>划分阶段的时间复杂性</h3><ul><li>划分问题为a个子问题</li><li>每个子问题大小为$\frac{n}{b}$</li><li>划分时间可直接得到=$D(n)$</li></ul></li><li><h3 id="递归求解阶段的时间复杂性"><a href="#递归求解阶段的时间复杂性" class="headerlink" title="递归求解阶段的时间复杂性"></a>递归求解阶段的时间复杂性</h3><ul><li>递归调用</li><li>求解时间=$aT(\frac{n}{b})$</li></ul></li><li><h3 id="合并阶段的时间复杂性"><a href="#合并阶段的时间复杂性" class="headerlink" title="合并阶段的时间复杂性"></a>合并阶段的时间复杂性</h3><ul><li>时间可以直接得到=$C(n)$</li></ul></li></ul><p>$$<br>T(n)=\Theta(1)\quad if;;n&lt;c<br>$$</p><p>$$<br>T(n)=aT(\frac{n}{b})+D(n)+C(n)\quad if\quad n\ge c<br>$$</p><h1 id="三、实际应用"><a href="#三、实际应用" class="headerlink" title="三、实际应用"></a>三、实际应用</h1><h2 id="1-大整数乘法"><a href="#1-大整数乘法" class="headerlink" title="1. 大整数乘法"></a>1. 大整数乘法</h2><ul><li><p>输入：ｎ位二进制整数Ｘ和Y</p></li><li><p>输出：X和Y的乘积</p></li><li><p>通常时间复杂度：$O(n^2)$</p></li><li><p>简单分治算法：$O(n^{1.59})$</p></li></ul><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>划分产生$A,B,C,D$</li><li>计算$A-B$和$C-D$</li><li>计算$\frac{n}{2}$位乘法$AC,BD,(A+B)(C+D)$</li><li>计算$(A+B)(C+D)-AC-BD$</li><li>AC左移n位，$(A+B)(C+D)-AC-BD$左移$\frac{n}{2}$位</li><li>计算XY</li></ol><p><img src="http://note.lizhihao999.cn/notes/20200818112253.png" alt="计算流程"></p><h3 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><ul><li><p>建立递归方程</p><p>$$<br>T(n)=\Theta(1)\quad if;;n=1<br>$$</p><p>$$<br>T(n)=3T(\frac{n}{2})+O(n)\quad if;;n&gt;1<br>$$</p></li></ul><ul><li>Master定理<br>$$<br>T(n)=O(n^{\log{3}})=O(n^{1.59})<br>$$</li></ul><h2 id="2-棋盘覆盖问题"><a href="#2-棋盘覆盖问题" class="headerlink" title="2. 棋盘覆盖问题"></a>2. 棋盘覆盖问题</h2><blockquote><p>参考<a href="http://blog.chinaunix.net/uid/26548237.html">梦醒潇湘love</a>博客</p></blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一个2^k ×2^k （k≥0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格。显然，特殊方格在棋盘中可能出现的位置有4^k 种，因而有4^k种不同的棋盘。棋盘覆盖问题（chess cover problem）要求用图所示的4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</p><p><img src="http://blog.chinaunix.net/attachment/201303/1/26548237_1362125215RWwI.png" alt="棋盘样例和骨牌样式"></p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>将2^k * 2^k的棋盘，先分成相等的四块子棋盘，其中特殊方格位于四个中的一个，构造剩下没特殊方格的三个字棋盘，将它们中的也假设一个方格为特殊方格。如果是：</p><p>左上角的子棋盘（若不存在特殊方格）：则将该子棋盘右下角的那个方格假设为特殊方格；</p><p>右上角的子棋盘（若不存在特殊方格）：则将该子棋盘左下角的那个方格假设为特殊方格；</p><p>左下角的子棋盘（若不存在特殊方格）：则将该子棋盘右上角的那个方格假设为特殊方格；</p><p>右下角的子棋盘（若不存在特殊方格）：则将该子棋盘左上角的那个方格假设为特殊方格；</p><p>上面四种情况，只可能且必定只有三种成立，那三个假设的特殊方格刚好构成一个L型骨牌，我们可以给它们作上相同的标志。这样四个子棋盘就分别都和原来的大棋盘类似，就可以用递归的算法解决。</p><p><img src="http://blog.chinaunix.net/attachment/201303/1/26548237_136212550647ax.png" alt="分割样例"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析的数学基础</title>
      <link href="/2020/04/26/suan-fa-fen-xi-de-shu-xue-ji-chu/"/>
      <url>/2020/04/26/suan-fa-fen-xi-de-shu-xue-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-计算复杂性函数的阶"><a href="#2-1-计算复杂性函数的阶" class="headerlink" title="2.1 计算复杂性函数的阶"></a>2.1 计算复杂性函数的阶</h1><h2 id="增长的阶"><a href="#增长的阶" class="headerlink" title="增长的阶"></a>增长的阶</h2><p>算法的实际运行时间受除算法设计本身以外很多其他因素的影响，如：指令集、操作系统、编译器…… </p><ul><li>如何描述算法的效率$\to$只与<strong>输入问题的规模</strong>有关<ul><li>增长率</li><li>时间复杂度</li></ul></li><li>忽略低阶项</li><li>保留最高阶项</li><li>忽略常系数</li><li>常见增长阶：$\Theta(1)$, $\Theta(lg,n)$, $\Theta(\sqrt[]{n})$, $\Theta(n)$, $\Theta(nlg,n)$, $\Theta(n^2)$, $\Theta(n^3)$, $\Theta(2^n)$, $\Theta(n!)$<ul><li>利用$\Theta(n^2)$表示插入排序的<strong>最坏</strong>运行时间</li></ul></li><li>增长记号$O, \Theta, \Omega, o, \omega$<ul><li>$O$表示<strong>渐进上界</strong></li><li>$\Theta$表示<strong>渐进紧界</strong></li><li>$\Omega$表示<strong>渐进下界</strong></li></ul></li></ul><h2 id="同阶函数集合-Theta"><a href="#同阶函数集合-Theta" class="headerlink" title="同阶函数集合 $\Theta$"></a>同阶函数集合 $\Theta$</h2><p>$$<br>\Theta(g(n))={,f(n)|\exists c_1,c_2 &gt;0,\forall n&gt;n_0,c_1g(n)\le f(n) \le c_2g(n) ,}<br>$$</p><p>称为与g(n)<strong>同阶的函数集合</strong></p><ul><li>若$f(n)\in \Theta(g(n))$, $g(n)$与$f(n)$同阶, 记作$f(n) = \Theta(g(n))$</li></ul><p>$\Theta(g(n))$例子：</p><ul><li>通常$f(n)=an^2+bn+c=\Theta(n^2)$，其中a,b,c是常数且$a&gt;0$</li><li>若$p(n)=\sum_{i=0}^{d}a_in^i$，其中$a_i$是常数且$a_d&gt;0$，则$p(n)=\Theta(n^d)$</li><li>$\Theta(n^0)$或者$\Theta(1)$为<strong>常数时间复杂性</strong></li></ul><h2 id="低阶函数集合-O"><a href="#低阶函数集合-O" class="headerlink" title="低阶函数集合 $O$"></a>低阶函数集合 $O$</h2><p>对于给定函数$g(n)$:<br>$$<br>O(g(n))=f{(n) 存在正常数c和n_0 满足对于所有n\ge n_0, 0 \le f(n) \le cg(n),}<br>$$<br>记作$f(n)\in O(g(n))$, 或简记为$f(n)=O(g(n))$</p><p>$\Theta(g(n))$与$O(g(n))$的关系：</p><ul><li>$f(n)=\Theta(g(n))\implies f(n)=O(g(n))$</li><li>$\Theta$强于$O$</li><li>$\Theta(g(n)) \subseteq O(g(n))$<ul><li>$an^2+bn+c=\Theta(n^2)$并且$an^2+bn+c=O(n^2)$</li><li>$an+b=O(n^2)$</li><li>$n=O(n^2)$</li></ul></li></ul><p><strong>如果 $f(n)=O(n^k)$ ，则称$f(n)$是多项式界限的​</strong></p><h2 id="严格低阶函数-o"><a href="#严格低阶函数-o" class="headerlink" title="严格低阶函数 $o$"></a>严格低阶函数 $o$</h2><p>对于给定函数$g(n)$:<br>$$<br>o(g(n))=f{(n) 存在任意正常数c,存在一个正数n_0 满足对于所有n\ge n_0, 0 \le f(n) &lt; cg(n),}<br>$$<br>记作$f(n)\in o(g(n))$, 或简记为$f(n)=o(g(n))$</p><p>$o$<strong>与$O$的关系：</strong></p><ul><li>$O$<strong>可能</strong>是或不是紧的<pre><code>- $2n^2=O(n^2)$是紧的，但$2n=O(n^2)$不是紧的</code></pre></li><li>$o$标记上界且<strong>不紧</strong><pre><code>- $2n=o(n^2)$，但是$2n^2\ne o(n^2)$</code></pre><ul><li>区别：$\cases{O:\exist,c,某个正常数\o:\forall,c,任意正常数}$</li></ul></li></ul><h2 id="高阶函数集合-Omega"><a href="#高阶函数集合-Omega" class="headerlink" title="高阶函数集合 $\Omega$"></a>高阶函数集合 $\Omega$</h2><p>对于给定函数$g(n)$:<br>$$<br>\Omega(g(n))=f{(n) ,存在正常数c和n_0 满足对于所有n\ge n_0, 0 \le cg(n) \le f(n),}<br>$$<br>记作$f(n)\in \Omega(g(n))$, 或简记为$f(n)=\Omega(g(n))$</p><p>$\Omega$用来描述运行时间的<strong>最好情况</strong>，对<strong>所有输入</strong>都正确</p><p>例如，对于插入排序：</p><ul><li>最好运行情况为$\Omega(n)$</li><li>运行时间为$\Omega(n)$ ($\Omega(n^2)$[<strong>x</strong>])</li><li>最坏运行时间为$\Omega(n^2)$</li></ul><p>也可以用来<strong>描述问题</strong>：</p><p>​    - 排序问题的时间复杂性为$\bold{\Omega(n)}$ $\to$ <strong>最好情况</strong></p><p><strong>$\bold{O,\Theta,\Omega}$的关系：</strong><br>$$<br>对于f(n)和g(n),f(n)=\Theta(g(n))当且仅当<br>f(n)=O(g(n))且f(n)=\Omega(g(n))<br>$$</p><h2 id="严格高阶函数集合-omega"><a href="#严格高阶函数集合-omega" class="headerlink" title="严格高阶函数集合 $\omega$"></a>严格高阶函数集合 $\omega$</h2><p>对于给定函数$g(n)$:<br>$$<br>\omega(g(n))=f{(n) \quad对于任意正常数c，存在正数n_0 满足对于所有n\ge n_0, 0 \le cg(n) \le f(n),}<br>$$<br>记作$f(n)\in \omega(g(n))$, 或简记为$f(n)=\omega(g(n))$</p><p>$$<br>\lim_{n\to \infty}\frac{f(n)}{g(n)}=\infty<br>$$</p><p>$\omega$表示<strong>不紧</strong>的下界</p><p>$$<br>\frac{n^2}{2}=\omega(n)，但\frac{n^2}{2}\ne \omega(n^2)<br>$$</p><p><strong>$\omega$与 $\Omega$ 的区别</strong>:$\cases{ \omega:,\exists,c存在正常数\ \Omega:,\forall,c,任意正常数 }$</p><p><strong>$\omega$与$o$的关系：</strong><br>$$<br>f(n)=\omega(g(n)) \iff g(n)=o(f(n))<br>$$</p><h2 id="渐进符号的性质"><a href="#渐进符号的性质" class="headerlink" title="渐进符号的性质"></a>渐进符号的性质</h2><ul><li><p><strong>传递性</strong>：$O, \Theta, \Omega, o, \omega$<br>$$<br>f(n)=\Theta(g(n))\and g(n)=\Theta(h(n)) \implies f(n)=\Theta(h(n))<br>$$</p></li><li><p><strong>自反性</strong>：$O,\Theta,\Omega $<br>$$<br>f(n)=\Theta(f(n))<br>$$</p></li><li><p><strong>对称性</strong>：$\Theta$<br>$$<br>f(n)=\Theta(g(n)) \iff g(n)=\Theta(f(n))<br>$$</p></li><li><p><strong>反对称性</strong>：$O, \Omega, o, \omega$<br>$$<br>f(n)=O(g(n)) \iff g(n)=\Omega(f(n))<br>$$</p></li></ul><p>$$<br>  f(n)=o(g(n)) \iff g(n)=\omega(f(n))<br>$$</p><ul><li><p><strong>等价性</strong>$\cases{\text{传递性}\自反性\对称性} $$\implies $ $\Theta$</p></li><li><p><strong>并非所有函数都可比</strong></p></li></ul><h1 id="2-2-和式的估计与界限"><a href="#2-2-和式的估计与界限" class="headerlink" title="2.2 和式的估计与界限"></a>2.2 和式的估计与界限</h1><h2 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h2><ol><li>线性和<br>$$<br>\sum_{k=1}^{n}(ca_k+b_k) = c\sum_{k=1}^{n}a_k+\sum_{k=1}^{n}b_k<br>$$</li></ol><p>   线性性质对于无限收敛级数同样适用。</p><p>   线性性质可以用来对项中包含渐进符号的和式求和，例如：</p><p>$$<br>\sum_{k=1}^{n}\Theta(f(k))=\Theta(\sum_{k=1}^{n}f(k))<br>$$</p><pre><code>       等式中，左边的\Theta符号作用于变量k，而右边的\Theta则作用于n。这种处理方法同样适用于无限收敛级数。</code></pre><ol start="2"><li>级数</li></ol><ul><li>等差级数：$\sum_{i=1}^{n}i=\frac{n(n+1)}{2}=\Theta(n^2)$</li><li>几何级数：$\sum_{k=0}^{n}x^k=1+x+x^2+…+x^n=\frac{x^{n+1}-1}{x-1}\quad(x\ne1)$</li><li>无限递减几何级数：$\sum_{k=0}^{\infin}x^k=\frac{1}{1-x}\quad|x|&lt;1$</li><li>裂项级数：$\sum_{k=1}^{n}(a_k-a_{k-1})=a_n-a_0$<ul><li>$\sum_{k=0}^{n-1}(a_k-a_{k+1})=a_0-a_n$</li><li>$\sum_{k=1}^{n-1}\frac{1}{k(k+1)}=\sum_{k=1}^{n-1}(\frac{1}{k}-\frac{1}{k+1})=1-\frac{1}{n}$</li></ul></li><li>调和级数：$H_n=\sum_{k=1}^{n}\frac{1}{k}=\ln{n}+O(1)$</li></ul><ol start="3"><li><p>常用公式</p><p>乘积：$lg(\prod_{k=1}^{n}a_k)=\sum_{k=1}^{n}\lg{a_k}$<br>平方和：$\sum_{k=0}^{n}k^2=\frac{n(n+1)(2n+1)}{6}$<br>立方和：$\sum_{k=0}^{n}=\frac{n^2(n+1)^2}{4}$</p></li></ol><ol start="4"><li><p>和的界限</p><p><strong>利用公式和定义</strong></p><p>例1：证明$\sum_{k=0}^{n}3^k=O(3^n)$<br>证：证明对于$c\ge\frac{3}{2}$存在一个$n_0，当n\ge n_0时\sum_{k=0}^{n}3^k\le c3^n$<br>当n=0时，$\sum_{k=0}^{n}3^k=1\le c=c3^n$<br>设$n\le m$时成立,令n=m+1,则<br>$\sum_{k=0}^{m+1}3^k=\sum_{k=0}^{m}3^k+3^{m+1}\le c3^m+3^{m+1}=c3^{m+1}(\frac{1}{3}+\frac{1}{c})\le c3^{m+1}$</p></li></ol><h2 id="求和的界限"><a href="#求和的界限" class="headerlink" title="求和的界限"></a>求和的界限</h2><ol><li><h4 id="放大法"><a href="#放大法" class="headerlink" title="放大法"></a>放大法</h4><p>例1：$\sum_{k=1}^{n}k\le\sum_{k=1}^{n}n=n^2$ $\impliedby\bold{\sum_{k=1}^{n}a_i\le n\times \max{a_k}}$</p></li></ol><ol start="2"><li><h4 id="前后项之比"><a href="#前后项之比" class="headerlink" title="前后项之比"></a>前后项之比</h4></li></ol><p>例2：设对于所有$k\ge0,\frac{a_{k+1}}{a_k}\le r\le1,求\sum_{k=0}^{n}a_k$的上界.<br>   解：$\frac{a_1}{a_0}\le r \implies a_1 \le a_0r,$<br>   $\frac{a_2}{a_1} \le r\implies a_2\le a_1r\le a_0r^2,$<br>   $\frac{a_3}{a_2}\le r\implies a_3\le a_2r \le a_0r^3,……$<br>   $\frac{a_k}{a_{k-1}}\le r\implies a_k\le a_{k-1}r \le a_0r^k$<br>   $\therefore \sum_{k=0}^{n}a_k\le \sum_{k=0}^{\infin}a_0r^k=a_0\sum_{k=0}^{\infin}r^k=\frac{a_0}{1-r}$</p><ol start="3"><li><h4 id="分裂和"><a href="#分裂和" class="headerlink" title="分裂和"></a>分裂和</h4><p>例4：用分裂和的方法求$\sum_{k=1}^{n}k$的下界.<br>解：$\sum_{k=1}^{n}k=\sum_{k=1}^{\frac{n}{2}}k+\sum_{k=\frac{n}{2}+1}^{n}k\ge\sum_{k=1}^{\frac{n}{2}}0+\sum_{k=\frac{n}{2}+1}^{n}\frac{n}{2}\ge(\frac{n}{2})^2=\Omega(n^2)$</p></li></ol><p>例5：求$\sum_{k=0}^{\infin}\frac{k^2}{2^k}$的上界.<br>   解：当$k\ge3$时，$\frac{\frac{(k+1)^2}{2^{k+1}}}{\frac{k^2}{2^k}}=\frac{(k+1)^2}{2k^2}\le\frac{8}{9}$<br>   于是$\quad \sum_{k=0}^{\infin}\frac{k^2}{2^k}=\sum_{k=0}^{2}\frac{k^2}{2^k}+\sum_{k=3}^{\infin}\frac{k^2}{2^k}\le\theta(1)+\sum_{k=3}^{\infin}\frac{9}{8}\cdot(\frac{8}{9})^k=O(1)$</p><p> (调和级数上界)例6：求$H_n=\sum_{k=1}^{n}\frac{1}{k}$的上界.<br>   解：$\sum_{k=1}^{n}\frac{1}{k}=\frac{1}{1}+(\frac{1}{2}+\frac{1}{3})+(\frac{1}{4}+\frac{1}{5}+\frac{1}{6}+\frac{1}{7})+…$<br>                       $\le \sum_{i=1}^{\lceil\log{n}\rceil}\sum_{j=0}^{2^i-1}\frac{1}{2^i+j}\le\sum_{i=0}^{\lceil\log{n}\rceil}1\le\log{n}+1=O(\log{n})$</p><ol start="4"><li><h4 id="单调函数"><a href="#单调函数" class="headerlink" title="单调函数"></a>单调函数</h4></li></ol><p>f(k)单调递增，则$\int_{m-1}^{n}f(x)dx\le\sum_{k=m}^{n}f(k)\le\int_{m}^{n+1}f(x)dx$<br>f(k)单调递减，则$\int_{m}^{n+1}f(x)dx\le\sum_{k=m}^{n}f(k)\le\int_{m-1}^{n}f(x)dx$</p><p>例7：调和级数：<br>$\sum_{k=1}^{n}\frac{1}{k}\ge\int_{1}^{n+1}\frac{dx}{x}=\ln{(n+1)}$ </p><p>$\quad\sum_{k=2}^{n}\cdot\frac{1}{k}\le\int_{1}^{n}\frac{dx}{x}=\ln{n}$</p><ol start="5"><li><h4 id="分割求和"><a href="#分割求和" class="headerlink" title="分割求和"></a>分割求和</h4></li></ol><p>$$<br>\sum_{k=1}^{n}k=\sum_{k=0}^{k_0-1}a_k+\sum_{k=k_0}^{n}a_k=\Theta(1)+\sum_{k=k_0}^{n}a_k<br>$$</p><p>对于算法分析中的和式，通常可以将和式分割。并忽略其常数个起始项。</p><p>一般情况下，该技巧适用于和式$\sum_{k=0}^{n}a_k$中每一项$a_k$均独立于n的情况。之后，对于任意常数k_0&gt;0，有<br>$$<br>\sum_{k=k_0}^{n}a_k=\sum_{k=0}^{k_0-1}a_k+\sum_{k=k_0}^{n}a_k=\Theta(1)+\sum_{k=k_0}^{n}a_k<br>$$</p><p>​    </p><h1 id="2-3-递归方程"><a href="#2-3-递归方程" class="headerlink" title="2.3 递归方程"></a>2.3 递归方程</h1><p>递归方程是使用小的输入值来描述一个函数的方程或不等式</p><h2 id="替换法"><a href="#替换法" class="headerlink" title="替换法"></a>替换法</h2><ol><li><strong>首先猜想</strong></li><li><strong>数学归纳法证明</strong></li></ol><h4 id="替换方法："><a href="#替换方法：" class="headerlink" title="替换方法："></a>替换方法：</h4><ul><li><p><strong>联想已知的$T(n)$</strong></p><p>例1：求解$2T(\frac{n}{2}+17)+n$</p><p>解：猜测：$T(n)=2T(\frac{n}{2}+17)+n$与$T(n)=2T(\frac{n}{2})+n$只相差一个$17$</p><p>​    当n充分大时$T(\frac{n}{2}+17)$与$T(\frac{n}{2})$的差别并不大，因为$\frac{n}{2}+17$与$\frac{n}{2}$相差小</p><p>​    我们可以猜$T(n)=O(n\lg{n})$</p><hr></li><li><p><strong>猜测上下界，减少不确定性范围</strong></p><p>例2：求解$T(n)=2T(\frac{n}{2})+n$</p><p>解：首先证明$T(n)=\Omega(n),T(n)=O(n^2)$</p><p>​    然后逐阶降低上界，提高上界</p><p>​    $\Omega(n)$的上一个阶是$\Omega(n\lg(n))$</p><p>​    $O(n^2)$的下一个阶是$O(n\lg{n})$</p><hr><p><strong>细微差别的处理</strong></p><ul><li>问题：猜测正确，数学归纳法的归纳步骤似乎证不出来</li><li>解决方法：从“猜想”中减去一个低阶项，可能会成功</li></ul><p>例3：求解$T(n)=T(\lfloor\frac{n}{2}\rfloor)+T(\lceil\frac{n}{2}\rceil)+1$</p><p>解：（1）我们猜$T(n)=O(n)$</p><p>​        证：$T(n)\le c\lfloor\frac{n}{2}\rfloor+c\lceil\frac{n}{2}\rceil+1=cn+1\ne cn$</p><p>​        <strong>证不出</strong>$T(n)=O(cn)$</p><p>​       （2）减去一个低阶项，猜$T(n)\le cn-b$，$b\ge0$是常数</p><p>​        证：设当$\le n-1$时成立<br>$$<br>T(n)=T(\lfloor\frac{n}{2}\rfloor+T(\lceil\frac{n}{2}\rceil)+1\le c\lfloor\frac{n}{2}\rfloor-b+c\lfloor\frac{n}{2}\rfloor-b+1)<br>$$</p><p>$$<br>=cn-2b+1=cn-b-b+1\le cn-b（只要b\ge1）<br>$$</p></li></ul><hr><p>  <strong>避免陷阱</strong></p><p>  例4：求解$T(n)=2T(\lfloor\frac{n}{2}\rfloor)+n$</p><p>  解：猜$T(n)=O(n)$</p><p>  ​    证：用数学归纳法证明$T(n)\le cn$<br>  $$<br>  T(n)\le2(c\lfloor\frac{n}{2}\rfloor)+n\le cn+n=O(n)\quad\color{red}{错误}<br>  $$<br>  错误之处：过早地使用了$O(n)$而陷入了陷阱应该在证明了$T(n)\le cn$才可用。从$T(n)\le cn+n$不可能得到$T(n)\le cn$，因为对于任何$c&gt;0$，我们都得不到$cn+n\le cn$</p><hr><ul><li><p>变量替换法：<strong>经变量替换把递归方程变换为熟悉的方程</strong></p><p>例5：求解$T(n)=2T(\sqrt{n})+\lg{n}$</p><p>解：令$m=\lg{n}$，则$n=2^m$，$T(2^m)=2T(2^{\frac{m}{2}})+m$</p><p>​        令$S(m)=T(2^m)$，则$T(2^{\frac{m}{2}})=S(\frac{m}{2})$</p><p>​        于是，$S(m)=2S(\frac{m}{2})+m$</p><p>​        显然，$S(m)=O(m\lg{m})$，即$T(2^m)=\Theta(m\lg{m})$</p><p>​        由于$2^m=n$，$m=\lg{n}$，$T(n)=\Theta(\lg{n}\times\lg(\lg{n}))$</p></li></ul><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><ol><li>循环地展开递归方程（画出递归树）</li><li>将递归方程转化为和式</li><li>使用求和技术解之</li></ol><hr><p><strong>递归树</strong></p><ul><li>根结点表示递归调用顶层的代价</li><li>内部节点，表示合并其子问题的代价</li><li>树的分支数量取决于子问题的数量</li><li>叶节点表示边界条件值</li></ul><p>例：$T(n)=3T(\frac{n}{4})+cn^2$，用递归法确定一个渐近上界，画出递归树。</p><p>解：</p><p>$T(n)=3T(\frac{n}{4})+cn^2$</p><p>$=cn^2+3[c\frac{n^2}{16}+3T(\frac{n}{16})]$</p><p>$=cn^2+3[c\frac{n^2}{16}+3[c\frac{n^2}{256}+3T(\frac{n}{64})]]$</p><p>……</p><p>$=3^0cn^2+3^1(\frac{n}{4})^2+3^2c(\frac{n}{4^2})^2+…+3^iT(\frac{n}{4^i})$</p><p>令$\frac{n}{4^i}=1\implies4^i=n\implies i=\log_4{n}$</p><p>$=3^0cn^2+3^1(\frac{n}{4})^2+3^2c(\frac{n}{4^2})^2+…+3^iT(1)$</p><p>$\le\sum_{i=0}^{\log_4{n}}{3^i(\frac{n}{4^i})^2+O(n)}\le n^2\sum_{i=0}^{\infin}{(\frac{3}{16})^i}$</p><p>$=n^2\times\frac{1}{1-\frac{3}{16}}=\frac{16}{13}n^2=O(n^2)$</p><p><img src="http://note.lizhihao999.cn/notes/20200818113634.png" alt="递归树"></p><hr><p>例6：$T(n)=n+3T(\lfloor\frac{n}{4}\rfloor)$</p><p>解：</p><img src="http://note.lizhihao999.cn/notes/20200819093653.png" style="zoom: 80%;"><h2 id="Master定理法"><a href="#Master定理法" class="headerlink" title="Master定理法"></a>Master定理法</h2><ul><li><strong>目的</strong>：求解$T(n)=aT(\frac{n}{b})+f(n)$型方程，$a\ge1,b&gt;0$是常数，$f(n)$是正函数</li><li><strong>方法</strong>：记住三种情况，不用纸笔直接求解</li></ul><hr><p><strong>Master定理</strong></p><p>设$a\ge1$和$b\ge1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数集上的函数$T(n)=aT(\frac{n}{b})+f(n)$. $T(n)$可以如下求解：</p><ol><li>若$f(n)=O(n^{\log_b{a}-\epsilon}),\epsilon&gt;0$是常数，则$T(n)=\Theta(n^{\log_b{a}})$</li><li>若$f(n)=\Theta(n^{\log_b{a}})$，则$T(n)=\Theta(n^{\log_b{a}}\lg{n})$</li><li>若$f(n)=\Omega(n^{\log_b{a}+\epsilon}),\epsilon&gt;0$是常数，且对所有充分大的$n,af(\frac{n}{b})\le cf(n),c&gt;1$是常数，则$T(n)=\Theta(f(n))$</li></ol><p><strong>直观地：</strong>用$f(n)$与$n^{\log_b{a}}$比较</p><ol><li><p>若$n^{\log_b{a}}$大，则$T(n)=\Theta(n^{\log_b{a}})$</p><ol start="2"><li>若$f(n)$大，则$T(n)=\Theta(f(n))$</li><li>若$f(n)$与$n^{\log_b{a}}$同阶，则$T(n)=\Theta(n^{\log_b{a}}\lg{n})=\Theta(f(n)\lg{n})$</li></ol></li></ol><p><img src="http://note.lizhihao999.cn/notes/20200818115456.png"><br>$$<br>\color{red}{对于红色部分，Master定理无能为力}<br>$$<br><strong>更进一步</strong>：</p><ol><li><p>在第一种情况，$f(n)$不仅小于$n^{\log_b{a}}$，必须多项式地小于，即对于一个常数$\epsilon&gt;0,;f(n)=O(\frac{n^{\log_b{a}}}{n^\epsilon})$</p></li><li><p>在第三种情况，$f(n)$不仅大于$n^{\log_b{a}}$，必须多项式地大于，即对于一个常数$\epsilon&gt;0,;f(n)=\Omega(n^{\log_b{a}}\cdot n^\epsilon)$</p></li></ol><hr><p>例7：求解$T(n)=9T(\frac{n}{3})+n$</p><p>解：$a=9,;b=3,;f(n)=n,;n^{\log_b{a}}=\Theta(n^2)$</p><p>​        $\because f(n)=n=O(n^{\log_b{a}-\epsilon}),;\epsilon=1$</p><p>​        $\therefore T(n)=\Theta(n^{\log_b{a}})=\Theta(n^2)$</p><p>例8：求解$T(n)=T(\frac{2n}{3})+1$</p><p>解：$a=1,;b=\frac{3}{2},;f(n)=1,;n^{log_{\frac{3}{2}}1}=n^0=1$</p><p>​        $f(n)=1=\Theta(1)=\Theta(n^{\log_b{a}}),;T(n)=\Theta(n^{\log_b{a}}\cdot\lg{n})=\Theta(\lg{n})$</p><p>例9：求解$T(n)=3T(\frac{n}{4})+n\lg{n}$</p><p>解：$a=3,;b=4,;f(n)=n\lg{n},;n^{\log_b{a}}=n^{\log_4{3}}=O(n^{0.793})$</p><p>​        （1）$f(n)=n\lg{n}\ge n=n^{\log_b{a}+\epsilon},;\epsilon\approx0.2$</p><p>​        （2）对所有$n,;af(\frac{n}{b})=3\times\frac{n}{4}\lg{\frac{n}{4}}=\frac{3}{4}n\lg{\frac{n}{4}}\le\frac{3}{4}n\lg{n}=cf(n),;c=\frac{3}{4}$</p><p>​        于是，$T(n)=\Theta(f(n))=\Theta(n\lg{n})$</p><p>例10：求解$T(n)=2T(\frac{n}{2})+n\lg{n}$</p><p>解：$a=2,;b=2,;f(n)=n\lg{n},;n^{log_b{a}}=n$</p><p>​        $f(n)=n\lg{n}$大于$n^{\log_b{a}}=n$</p><p>​        但<strong>不是多项式地大于</strong>，Master定理<strong>不适用</strong>于该$T(n)$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法概论</title>
      <link href="/2020/04/25/suan-fa-gai-lun/"/>
      <url>/2020/04/25/suan-fa-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h1><h2 id="（1）计算"><a href="#（1）计算" class="headerlink" title="（1）计算"></a>（1）计算</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>可由一个<strong>给定计算模型</strong>机械地<strong>执行的规则</strong>或<strong>计算步骤序列</strong>称为该计算模型的一个计算</p><ul><li>一个计算机程序是一个计算</li><li>计算可能永远不会停止</li><li>不是算法</li></ul><h2 id="（2）算法"><a href="#（2）算法" class="headerlink" title="（2）算法"></a>（2）算法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>算法是满足下列条件的计算：</li></ol><ul><li><strong>有穷性/终止性</strong>：有限步内必须停止</li><li><strong>确定性</strong>：每一步都是严格定义和确定的动作</li><li><strong>可行性</strong>：每一个动作都能够被精确地机械执行</li><li><strong>输入</strong>：有一个满足给定约束条件的输入<ul><li>函数可以没有输入</li><li>算法必须有输入</li></ul></li><li><strong>输出</strong>：满足给定约束条件地结果</li></ul><ol><li>算法的目的是求解问题</li><li>一个算法<strong>面向一个问题</strong>，而不是仅求解一个问题的一个或几个实例</li></ol><h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><ol><li><p>伪代码</p></li><li><p>实例</p><pre class="line-numbers language-pseudocode"><code class="language-pseudocode">Input: A[1, ..., n] = n个数Output: A[1, ..., n] = n个sorted数FOR j=2 To n Do    key <- A[j];    i <- j-1    WHILE i>0 AND A[i]>key Do        A[i+1] <- A[i];        i <- i-1;    A[i+1] <- key;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="（3）问题"><a href="#（3）问题" class="headerlink" title="（3）问题"></a>（3）问题</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>设Input和Output是两个<strong>集合</strong>。一个问题是一个<strong>关系R $\subseteq$ Input × Output</strong></p><ul><li><p><strong>Input</strong>称为问题R的<strong>输入集合</strong><br>$$<br>Input = { &lt;a_1,….,a_n&gt; | a_i是整数 }<br>$$</p><ul><li>Input的每个元素称为R的一个输入</li></ul></li><li><p><strong>Output</strong>称为问题R的<strong>输出或结果集合</strong><br>$$<br>Output = { &lt;b_1,….,b_n&gt; | b_i是整数，且b_i  \le…\le b_n}<br>$$</p><ul><li>Output的每个元素称为R的一个结果</li></ul></li><li><p><strong>问题</strong>定义了<strong>输入和输出的关系</strong> $\to$ </p></li></ul><p>$$<br>R = {<br>( &lt; a_1, … ,a_n &gt;, &lt; b_1, …, b_n &gt; ) | &lt; a_1, … , a_n &gt; \in Input, \<br>&lt; b_1, … ,b_n &gt; \in Output,<br>{a_1, … ,a_n} = {b_1, … ,b_n}<br>}<br>$$</p><h1 id="1-2-计算机科学中算法的位置"><a href="#1-2-计算机科学中算法的位置" class="headerlink" title="1.2 计算机科学中算法的位置"></a>1.2 计算机科学中算法的位置</h1><hr><h2 id="（1）算法是计算机科学基础的重要主题"><a href="#（1）算法是计算机科学基础的重要主题" class="headerlink" title="（1）算法是计算机科学基础的重要主题"></a>（1）算法是计算机科学基础的重要主题</h2><h2 id="（2）计算机科学的体系"><a href="#（2）计算机科学的体系" class="headerlink" title="（2）计算机科学的体系"></a>（2）计算机科学的体系</h2><h3 id="解决一个计算问题的过程"><a href="#解决一个计算问题的过程" class="headerlink" title="解决一个计算问题的过程"></a>解决一个计算问题的过程</h3><ol><li>可计算否</li><li>能行计算否</li><li>算法设计与分析</li><li>用计算机语言实现算法</li><li>软件系统</li></ol><p>###　可计算理论</p><ul><li>计算模型</li><li>可计算问题／不可计算问题</li><li>计算模型的等价性$\to$ 图灵/Church命题</li></ul><h3 id="计算复杂性理论"><a href="#计算复杂性理论" class="headerlink" title="计算复杂性理论"></a>计算复杂性理论</h3><ul><li>在给定的计算模型夏研究问题的复杂性<ul><li>固有复杂性</li><li>上界</li><li>下界</li><li>平均</li><li>复杂性问题的分类 $\to$ P/NP</li><li>抽象复杂性研究</li></ul></li></ul><h3 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h3><ul><li>可计算问题的算法的设计与分析</li><li>设计算法的理论、方法和技术</li><li>分析算法的理论、方法和技术</li></ul><h3 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h3><ul><li>系统软件</li><li>工具软件</li><li>应用软件</li></ul><h1 id="1-3-算法分析引论"><a href="#1-3-算法分析引论" class="headerlink" title="1.3 算法分析引论"></a>1.3 算法分析引论</h1><hr><h2 id="（1）算法的正确性"><a href="#（1）算法的正确性" class="headerlink" title="（1）算法的正确性"></a>（1）算法的正确性</h2><ul><li><p>一个算法是正确 $\to$ 对于每一个输入都最终停止，而且产生正确的输出</p></li><li><p>不正确算法</p><ul><li>不停止</li><li>对所有输入都停止，但对输入产生不正确结果</li></ul></li><li><p>近似算法</p><ul><li>对所有输入都停止</li><li>产生近似正确的解或产生不多的不正确解</li></ul></li></ul><h2 id="（2）算法正确性的证明"><a href="#（2）算法正确性的证明" class="headerlink" title="（2）算法正确性的证明"></a>（2）算法正确性的证明</h2><ul><li>证明算法对所有输入都停止</li><li>证明对每个输入都产生正确结果</li><li>调试程序 $\ne$ 程序正确性证明</li></ul><h2 id="（3）算法复杂性分析"><a href="#（3）算法复杂性分析" class="headerlink" title="（3）算法复杂性分析"></a>（3）算法复杂性分析</h2><ul><li><p>目的</p><ul><li>预测算法对不同输入所需资源量</li></ul></li><li><p>复杂性测度 $\to$ <strong>输入大小的函数</strong></p><ul><li>时间</li><li>空间</li><li>I/O</li></ul></li><li><p>用途</p><ul><li>为求解一个问题选择最佳算法、最佳设备</li></ul></li><li><p>需要的数学基础</p><ul><li>离散数学</li><li>组合数学</li><li>概率论</li><li>代数</li></ul></li><li><p>需要的数学能力</p><ul><li>建立算法复杂性的数学模型</li><li>数学模型化简</li></ul></li></ul><h2 id="（4）算法复杂性分析的度量"><a href="#（4）算法复杂性分析的度量" class="headerlink" title="（4）算法复杂性分析的度量"></a>（4）算法复杂性分析的度量</h2><h3 id="输入的大小（输入规模）"><a href="#输入的大小（输入规模）" class="headerlink" title="输入的大小（输入规模）"></a>输入的大小（输入规模）</h3><ul><li>设Input是问题R的输入集合</li><li>R的<strong>输入大小</strong>是一个函数<strong>F：Input $\to$ N, N是正整数集合</strong></li><li>输入规模量度<ul><li>最自然的量度：<strong>输入中的项数</strong></li><li>对于研究的每个问题将指出所使用的输入规模量度</li></ul></li></ul><h3 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><ul><li>一个算法对特定输入的时间复杂性是该算法对该输入产生结果需要的<strong>原子(基本)操作数</strong>或<strong>步数</strong></li><li><strong>注意</strong><ul><li>时间复杂性是输入大小的函数</li><li>我们假设每一步的执行需要常数时间，实际上每步需要的时间量可能不同</li></ul></li></ul><h3 id="空间复杂性"><a href="#空间复杂性" class="headerlink" title="空间复杂性"></a>空间复杂性</h3><ul><li>一个算法对特定输入的空间复杂性是该算法对该输入产生结果所需要的存储空间大小</li></ul><h3 id="最坏复杂性"><a href="#最坏复杂性" class="headerlink" title="最坏复杂性"></a>最坏复杂性</h3><p>设Input是问题R的输入集合，$Complexity(X)$是求解R的算法A的复杂性函数，$size(y)$是确定R中输入大小的函数，A的最坏复杂性是<br>$$<br>Max{ Complexity,(size(y)),|,y\in Input }<br>$$<br>我们往往集中于只求<strong>最坏情况运行时间</strong>：</p><ul><li>最坏复杂性给出任何输入的运行时间的一个<strong>上界</strong>，能够确保该算法绝不需要更长的时间</li><li>对某些算法，最坏情况经常出现<ul><li>例：在数据库中检索一条不存在的信息</li></ul></li><li>平均复杂性往往与最坏复杂性大致一样差<ul><li>例：随机选择n个数并应用插入排序</li></ul></li></ul><h3 id="最小复杂性"><a href="#最小复杂性" class="headerlink" title="最小复杂性"></a>最小复杂性</h3><p>$$<br>Min{ Complexity,(size(y)),|,y\in Input }<br>$$</p><h3 id="平均复杂性"><a href="#平均复杂性" class="headerlink" title="平均复杂性"></a>平均复杂性</h3><p>设 $y\in Input$, y作为算法A的输入出现的概率是$p_y$，A的平均复杂性为</p><p>$$<br> \sum_{y\in Input} p_y \times complexity(size(y))<br>$$</p><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><ul><li><strong>抽象</strong>：<ul><li><strong>只考虑公式中最重要的项</strong></li><li>忽略<strong>低阶项</strong></li><li>忽略<strong>最重要项</strong>的<strong>常系数</strong></li></ul></li><li>记作：**$\Theta(n^2)$**</li><li>如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，通常认为前者比后者有效</li></ul><h2 id="（5）算法分析的模型"><a href="#（5）算法分析的模型" class="headerlink" title="（5）算法分析的模型"></a>（5）算法分析的模型</h2><h3 id="随机访问模型-Random-Access-Model-RAM"><a href="#随机访问模型-Random-Access-Model-RAM" class="headerlink" title="随机访问模型(Random-Access-Model, RAM)"></a>随机访问模型(Random-Access-Model, RAM)</h3><ul><li>单处理机<ul><li>串行执行</li><li>无并发</li></ul></li><li>指令（所需时间为<strong>常量</strong>）<ul><li>算术指令<ul><li>加减乘除</li><li>向上/向下取整</li><li>取余</li></ul></li><li>数据移动指令<ul><li>装入</li><li>存储</li><li>复制</li></ul></li><li>控制指令<ul><li>条件/无条件转移</li><li>子程序调用/返回</li></ul></li></ul></li><li>基本数据类型<ul><li>整数型</li><li>浮点实数型</li></ul></li><li>基本操作 $\to$ 每个操作常数的时间</li></ul><h3 id="并行多处理机模型-PRAM"><a href="#并行多处理机模型-PRAM" class="headerlink" title="并行多处理机模型(PRAM)"></a>并行多处理机模型(PRAM)</h3><p>暂不涉及</p><h1 id="1-4-算法设计引论"><a href="#1-4-算法设计引论" class="headerlink" title="1.4 算法设计引论"></a>1.4 算法设计引论</h1><hr><h2 id="（1）算法设计模式"><a href="#（1）算法设计模式" class="headerlink" title="（1）算法设计模式"></a>（1）算法设计模式</h2><ul><li>暴力搜索</li><li>分治法</li><li>图搜索与枚举<ul><li>分支界限</li><li>回溯</li></ul></li><li>随机化方法</li></ul><h2 id="（2）算法实现方法"><a href="#（2）算法实现方法" class="headerlink" title="（2）算法实现方法"></a>（2）算法实现方法</h2><ul><li>递归与迭代</li><li>顺序、并行与分布式</li><li>确定性与非确定性</li><li>近似求解与精确求解</li><li>量子算法</li></ul><h2 id="（3）最优化设计方法"><a href="#（3）最优化设计方法" class="headerlink" title="（3）最优化设计方法"></a>（3）<strong>最优化设计方法</strong></h2><ul><li>线性规划</li><li>动态规划</li><li>贪心法</li><li>启发式方法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gunicorn基本使用</title>
      <link href="/2020/04/03/gunicorn-ji-ben-shi-yong/"/>
      <url>/2020/04/03/gunicorn-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="开启Gunicorn任务"><a href="#开启Gunicorn任务" class="headerlink" title="开启Gunicorn任务"></a>开启Gunicorn任务</h1><pre class="line-numbers language-shell"><code class="language-shell">gunicorn --bind unix:/tmp/域名.socket projectname.wsgi:application<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="查找masterpid"><a href="#查找masterpid" class="headerlink" title="查找masterpid"></a>查找masterpid</h1><p>首先获取Gunicorn进程树，获取进程pid</p><pre class="line-numbers language-shell"><code class="language-shell">pstree -ap|grep gunicorn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402234636.png"></p><p>可以看到，29585为主进程</p><h1 id="重启Gunicorn任务"><a href="#重启Gunicorn任务" class="headerlink" title="重启Gunicorn任务"></a>重启Gunicorn任务</h1><pre class="line-numbers language-shell"><code class="language-shell">kill -HUP pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="退出Gunicorn任务"><a href="#退出Gunicorn任务" class="headerlink" title="退出Gunicorn任务"></a>退出Gunicorn任务</h1><pre class="line-numbers language-shell"><code class="language-shell">kill -9 pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查看Gunicorn进程树，可以看到主进程已经停止</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402234859.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 脱坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu服务器安装Anaconda</title>
      <link href="/2020/04/03/ubuntu-fu-wu-qi-an-zhuang-anaconda/"/>
      <url>/2020/04/03/ubuntu-fu-wu-qi-an-zhuang-anaconda/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p></blockquote><h1 id="Anaconda-下载"><a href="#Anaconda-下载" class="headerlink" title="Anaconda 下载"></a>Anaconda 下载</h1><ul><li><h2 id="Anaconda官网"><a href="#Anaconda官网" class="headerlink" title="Anaconda官网"></a><a href="https://www.anaconda.com/">Anaconda官网</a></h2><p>如果有梯子的话速度会比较快，如果没有梯子的话，速度可能会<strong>很慢</strong>。</p></li><li><h2 id="清华大学开源软件镜像站"><a href="#清华大学开源软件镜像站" class="headerlink" title="清华大学开源软件镜像站"></a><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华大学开源软件镜像站</a></h2><p>建议使用这种方式下载（<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">下载地址</a>），按时间排序，选择合适的最新版：<code>64位Linux版</code></p><p>可以先下载到本地，通过<code>Xftp</code>传到Ubuntu服务器，也可以直接下载到服务器端。</p></li></ul><h1 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h1><ol><li><p>在终端中进到<code>.sh</code>文件所在文件夹</p></li><li><p>运行<code>.sh</code>文件</p><pre class="line-numbers language-shell"><code class="language-shell">bash Anaconda3-2020.02-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>一路<code>Enter</code>，然后输入<code>yes</code>，接受协议</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/%E6%89%B9%E6%B3%A8%202020-04-02%20230506.png"></p></li><li><p>选择安装路径，<code>Enter</code>选择默认路径，也可以自己更改</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402231106.png"></p><p>选择完成后，开始安装</p></li><li><p>安装完成后，选择使用<code>conda</code></p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402232510.png"></p></li><li><p>安装成功</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402232718.png"></p></li></ol><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><ol><li><p>打开配置文件</p><pre class="line-numbers language-shell"><code class="language-shell">vim ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加环境路径</p><pre><code>export PATH=/home/XXX/anaconda3/bin:$PATH</code></pre><p>填入自己的安装路径</p></li><li><p>激活环境</p><pre class="line-numbers language-shell"><code class="language-shell">source ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看Anaconda和python版本</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200402233509.png"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 脱坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置虚拟环境</title>
      <link href="/2020/03/29/linux-pei-zhi-xu-ni-huan-jing/"/>
      <url>/2020/03/29/linux-pei-zhi-xu-ni-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h1><p>输入命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sudo pip install virtualenvsudo pip install virtualenvwrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>virtualenv</strong>是虚拟环境的软件工具，可以在系统中建立多个互不干扰的虚拟环境</li><li><strong>virtualenvwrapper</strong>对<strong>virtualenv</strong>进行封装，更加方便管理虚拟环境</li></ul><h1 id="virtualenv的使用"><a href="#virtualenv的使用" class="headerlink" title="virtualenv的使用"></a>virtualenv的使用</h1><ul><li><p>新建虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">mkdir Myprojectcd Myprojectvirtualenv --python=python3 venvvirtualenv --no-site-packages --python=python3.7 venv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>--python=python3</code>指定python环境</li><li><code>--no-site-packages</code>指定获取独立第三方包的环境</li><li><code>venv</code>为虚拟环境名称</li></ul></li><li><p>激活虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">source venv/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>退出虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h1 id="配置一致的开发环境"><a href="#配置一致的开发环境" class="headerlink" title="配置一致的开发环境"></a>配置一致的开发环境</h1><ul><li><p>导出当前python环境的包</p><pre class="line-numbers language-shell"><code class="language-shell">pip freeze > requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前环境所有依赖的包及其版本都会收集到<code>requiements.txt</code>中</p></li><li><p>在新环境中安装项目所需的包</p><pre class="line-numbers language-shell"><code class="language-shell">pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h1 id="使用virtualenvwrapper管理虚拟环境"><a href="#使用virtualenvwrapper管理虚拟环境" class="headerlink" title="使用virtualenvwrapper管理虚拟环境"></a>使用virtualenvwrapper管理虚拟环境</h1><h2 id="设置Linux环境变量"><a href="#设置Linux环境变量" class="headerlink" title="设置Linux环境变量"></a>设置Linux环境变量</h2><ul><li><p>将<strong>virtualenvwrapper</strong>添加到当前的环境变量中，先打开<strong>bashrc</strong>文件（针对当前用户）</p><pre class="line-numbers language-shell"><code class="language-shell">sudo vim ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>写入以下代码</p><pre class="line-numbers language-shell"><code class="language-shell">export WORKON_HOME=~/Envs #设置virtualenv的统一管理目录export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'   export VIRTUALENVWRAPPER_PYTHON=/home/admin/anaconda3/bin/python3 #指定python解释器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>执行<strong>virtualenvwrapper</strong>安装脚本</p><pre class="line-numbers language-shell"><code class="language-shell">source /home/admin/anaconda3/bin/virtualenvwrapper.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>激活设置</p><pre class="line-numbers language-shell"><code class="language-shell">source ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="virtualenvwrapper的使用"><a href="#virtualenvwrapper的使用" class="headerlink" title="virtualenvwrapper的使用"></a>virtualenvwrapper的使用</h2><p><strong>virtualenvwrapper</strong>能够将所有的虚拟环境目录集中起来，能够对所有的虚拟环境进行统一管理，不需要自己去找对应的虚拟环境目录去激活。</p><ul><li><p>创建虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] ENVNAMEmkvirtualenv dataadmin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>激活虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">worken dataadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>退出当前虚拟环境</p><pre class="line-numbers language-shell"><code class="language-shell">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以直接切换到另外的环境</p><pre class="line-numbers language-shell"><code class="language-shell">worken anothervenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除虚拟环境（需要先退出）</p><pre class="line-numbers language-shell"><code class="language-shell">rmvirtualenv dataadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>所有虚拟环境列表</p><pre class="line-numbers language-shell"><code class="language-shell">lsvirtualenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>导航到当前环境的目录</p><pre class="line-numbers language-shell"><code class="language-shell">cdvirtualenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>导航到当前环境的<strong>site-packages</strong>目录</p><pre class="line-numbers language-shell"><code class="language-shell">cdsitepackages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>site-packages</strong>列表</p><pre class="line-numbers language-shell"><code class="language-shell">lssitepackages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>更多操作见<a href="https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html">官网</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 脱坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm远程调试</title>
      <link href="/2020/03/28/pycharm-yuan-cheng-diao-shi/"/>
      <url>/2020/03/28/pycharm-yuan-cheng-diao-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>IDE：PyCharm 2019.3.3 (Professional Edition)<br>ECS：腾讯云 Ubuntu 18.04.4 LTS</p></blockquote><p>利用pycharm进行远程调试，主要有两种模式：</p><ul><li>利用云服务器端的环境调试本地代码，实现本地开发，Linux云端调试</li><li>在本地调试云端代码</li></ul><p>两种模式共同点都需要在本地的pycharm连接上云服务器的环境，首先需要先配置好服务器端的环境。</p><h2 id="一-配置远程连接"><a href="#一-配置远程连接" class="headerlink" title="一. 配置远程连接"></a>一. 配置远程连接</h2><h4 id="1-进入Pycharm菜单栏，如下图依次点击Tools-gt-Deployment-gt-Configuration…"><a href="#1-进入Pycharm菜单栏，如下图依次点击Tools-gt-Deployment-gt-Configuration…" class="headerlink" title="1. 进入Pycharm菜单栏，如下图依次点击Tools->Deployment->Configuration…"></a>1. 进入Pycharm菜单栏，如下图依次点击Tools-&gt;Deployment-&gt;Configuration…</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328204451.png" alt="菜单栏"></p><h4 id="2-右侧点击-添加SFTP"><a href="#2-右侧点击-添加SFTP" class="headerlink" title="2. 右侧点击+添加SFTP"></a>2. 右侧点击+添加SFTP</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328213703.png"></p><h4 id="3-设置Name（自己设置）"><a href="#3-设置Name（自己设置）" class="headerlink" title="3. 设置Name（自己设置）"></a>3. 设置Name（自己设置）</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328213919.png"></p><h4 id="4-填写连接配置"><a href="#4-填写连接配置" class="headerlink" title="4. 填写连接配置"></a>4. 填写连接配置</h4><ul><li><strong>Host（外网IP）</strong></li><li><strong>端口</strong></li><li><strong>用户名</strong></li><li><strong>密码</strong></li></ul><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/1.png" style="zoom:80%;"><p>填好之后可以<strong>测试连接</strong></p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/2.png"></p><p>之后点击<strong>Autodetect</strong>确定根目录</p><h4 id="5-点击OK结束"><a href="#5-点击OK结束" class="headerlink" title="5. 点击OK结束"></a>5. 点击OK结束</h4><h2 id="二-配置远程解释器"><a href="#二-配置远程解释器" class="headerlink" title="二. 配置远程解释器"></a>二. 配置远程解释器</h2><h4 id="1-进入Pycharm菜单栏，如下图依次点击File-gt-Settings…"><a href="#1-进入Pycharm菜单栏，如下图依次点击File-gt-Settings…" class="headerlink" title="1. 进入Pycharm菜单栏，如下图依次点击File->Settings…"></a>1. 进入Pycharm菜单栏，如下图依次点击File-&gt;Settings…</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328223125.png"></p><h4 id="2-选择Project-gt-Project-Interpreter"><a href="#2-选择Project-gt-Project-Interpreter" class="headerlink" title="2. 选择Project->Project Interpreter"></a>2. 选择Project-&gt;Project Interpreter</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328223329.png"></p><h4 id="3-点击添加解释器"><a href="#3-点击添加解释器" class="headerlink" title="3. 点击添加解释器"></a>3. 点击添加解释器</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328223536.png"></p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328223554.png"></p><h4 id="4-选择SSH-Interpreter-gt-Existing-server-configuration-gt-刚刚新建的Deployment"><a href="#4-选择SSH-Interpreter-gt-Existing-server-configuration-gt-刚刚新建的Deployment" class="headerlink" title="4. 选择SSH Interpreter->Existing server configuration->刚刚新建的Deployment"></a>4. 选择SSH Interpreter-&gt;Existing server configuration-&gt;刚刚新建的Deployment</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/4.png"></p><h4 id="5-选择Move-gt-Next"><a href="#5-选择Move-gt-Next" class="headerlink" title="5. 选择Move ->Next"></a>5. 选择Move -&gt;Next</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331105544.png"></p><h4 id="6-设置远端解释器"><a href="#6-设置远端解释器" class="headerlink" title="6. 设置远端解释器"></a>6. 设置远端解释器</h4><p>我在这里设置为虚拟环境中的解释器，是否需要<strong>sudo</strong>权限根据自己的实际需要</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/5.png"></p><p>可以看到pycharm在<code>tmp</code>文件夹下新建了<code>pycharm_project_xxx</code>文件夹用于放置本地的同步项目代码</p><p>点击<strong>Finish</strong>结束配置</p><h4 id="7-成功后可以看到环境中的安装的依赖包"><a href="#7-成功后可以看到环境中的安装的依赖包" class="headerlink" title="7. 成功后可以看到环境中的安装的依赖包"></a>7. 成功后可以看到环境中的安装的依赖包</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328224945.png"></p><p>点击<strong>Apply</strong>完成配置</p><h4 id="8-检查Mappings"><a href="#8-检查Mappings" class="headerlink" title="8. 检查Mappings"></a>8. 检查Mappings</h4><ul><li><strong>Tools-&gt;Deployment-&gt;Configuration…</strong></li><li><strong>查看之前Deployment的Mappings下的Deployment path</strong></li></ul><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331111651.png"></p><ul><li><strong>如果没有自动定位可以手动设置</strong></li></ul><h2 id="三-远程调试本地代码"><a href="#三-远程调试本地代码" class="headerlink" title="三.远程调试本地代码"></a>三.远程调试本地代码</h2><blockquote><p>以<strong>Django</strong>项目为例</p></blockquote><h4 id="1-设置ALLOWED-HOSTS"><a href="#1-设置ALLOWED-HOSTS" class="headerlink" title="1. 设置ALLOWED_HOSTS"></a>1. 设置ALLOWED_HOSTS</h4><p>允许所有的host访问</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># DataAdmin/settings.py</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"*"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-自动同步代码"><a href="#2-自动同步代码" class="headerlink" title="2. 自动同步代码"></a>2. 自动同步代码</h4><p>实际的运行过程是：pycharm将本地代码<strong>自动同步</strong>到服务器上对应的的<code>tmp/pycharm_projectXXX</code>文件夹中，实际运行时也是运行的服务器端的代码。</p><ul><li><strong>可以通过File Transfer查看同步情况</strong></li></ul><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331112257.png"></p><ul><li><strong>可以通过Tools-&gt;Deployment-&gt;Browse Remote Host查看服务器端目录结构</strong></li></ul><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331112330.png"></p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331112502.png"></p><h4 id="3-调试运行项目"><a href="#3-调试运行项目" class="headerlink" title="3. 调试运行项目"></a>3. 调试运行项目</h4><ul><li><strong>Run manage.py-&gt;Edit  Configurations…</strong></li></ul><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200331110847.png"></p><ul><li><strong>检查Script path是否对应自己的项目地址</strong></li><li><strong>添加Parameters：<code>runserver 0.0.0.0:8000</code></strong></li><li><strong>Apply-&gt;OK</strong></li><li><strong>Run</strong></li></ul><p>打开<strong>IP:8000</strong>，可以看到自己的网页</p><h2 id="四-远程调试云端代码"><a href="#四-远程调试云端代码" class="headerlink" title="四. 远程调试云端代码"></a>四. 远程调试云端代码</h2><h4 id="1-连接到服务器Tools-gt-Start-SSH-session…"><a href="#1-连接到服务器Tools-gt-Start-SSH-session…" class="headerlink" title="1. 连接到服务器Tools->Start SSH session…"></a>1. 连接到服务器Tools-&gt;Start SSH session…</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328231327.png"></p><h4 id="2-选择对应的HOST"><a href="#2-选择对应的HOST" class="headerlink" title="2.选择对应的HOST"></a>2.选择对应的HOST</h4><p>连接成功后，会有终端显示</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/7.png"></p><h4 id="3-显示服务器目录结构Tools-gt-Deployment-gt-Browse-Remote-Host"><a href="#3-显示服务器目录结构Tools-gt-Deployment-gt-Browse-Remote-Host" class="headerlink" title="3. 显示服务器目录结构Tools->Deployment->Browse Remote Host"></a>3. 显示服务器目录结构Tools-&gt;Deployment-&gt;Browse Remote Host</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328231901.png"></p><p>选择后会显示出服务器目录结构，选中项目文件能够打开编辑</p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/9.png"></p><h4 id="4-编辑完成后更新版本"><a href="#4-编辑完成后更新版本" class="headerlink" title="4. 编辑完成后更新版本"></a>4. 编辑完成后更新版本</h4><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328232528.png"></p><p>可以设置自动上传更新<strong>Tools-&gt;Deployment-&gt;Automatic Upload</strong></p><p><img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200328232726.png"></p><h4 id="5-在终端调试运行"><a href="#5-在终端调试运行" class="headerlink" title="5. 在终端调试运行"></a>5. 在终端调试运行</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 脱坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Channels实现WebSocket协议</title>
      <link href="/2020/03/08/li-yong-channels-shi-xian-websocket-xie-yi/"/>
      <url>/2020/03/08/li-yong-channels-shi-xian-websocket-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议与WebSocket协议"><a href="#HTTP协议与WebSocket协议" class="headerlink" title="HTTP协议与WebSocket协议"></a>HTTP协议与WebSocket协议</h1><h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><p>​    HTTP协议指超文本传输协议（<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），是用于从万维网服务器传输超文本到本地浏览器的传送协议，是基于TCP/IP协议之上的应用层协议。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径，通信速度很快。</li><li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。</li><li><strong>无连接</strong>：限制每次连接只处理<strong>一个</strong>请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li><strong>支持客户端/服务器模型</strong></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>HTTP是基于客户/服务器模式，且面向连接的。典型的HTTP事务处理有如下的过程：</p><ol><li>客户与服务器建立连接；</li><li>客户向服务器提出请求；</li><li>服务器接受请求，并根据请求返回相应的文件作为应答；</li><li>客户与服务器关闭连接。</li></ol><h2 id="WebSocket协议简介"><a href="#WebSocket协议简介" class="headerlink" title="WebSocket协议简介"></a>WebSocket协议简介</h2><p>​    现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p>​    HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。    </p><p>​    <strong>WebSocket</strong>是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行<strong>双向数据传输</strong>。</p><h1 id="Django-Channels实现WebSocket实时通讯"><a href="#Django-Channels实现WebSocket实时通讯" class="headerlink" title="Django Channels实现WebSocket实时通讯"></a>Django Channels实现WebSocket实时通讯</h1><blockquote><p><a href="https://channels.readthedocs.io/en/latest/">官方文档</a></p></blockquote><p>​    <strong>Channels</strong>是一个采用Django并将其功能拓展到HTTP以外的项目，以处理WebSocket协议。它基于称为<a href="http://asgi.readthedocs.io/">ASGI</a>的Python规范构建。</p><p>​    接下来基于官方Tutorial1-2简单介绍Channels的使用。</p><p>​    首先需要安装Django和Channels</p><pre class="line-numbers language-powershell"><code class="language-powershell">pip install djangopip install channels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    创建一个Django项目，并进入项目根目录：</p><pre class="line-numbers language-powershell"><code class="language-powershell">django<span class="token operator">-</span>admin startproject mysitecd mysite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    接下来创建Channels的根路由<code>routing.py</code>，channels的路由配置与Django URLconf相似，它告诉Channels当Channels服务器接收到HTTP请求时要运行什么代码。</p><p>​    首先从一个空的路由配置开始，创建文件<code>mysite/routing.py</code>，包含以下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/routing.py</span><span class="token keyword">from</span> channels<span class="token punctuation">.</span>routing <span class="token keyword">import</span> ProtocolTypeRouterapplication <span class="token operator">=</span> ProtocolTypeRouter<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token comment" spellcheck="true"># (http->django views is added by default)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    然后将Channels库在应用列表中进行注册：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/settings.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 新添加</span>    <span class="token string">'channels'</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    继续编辑<code>mtsite/settings.py</code>将Channels指向根路由配置，添加以下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/settings.py</span><span class="token comment" spellcheck="true"># Channels</span>ASGI_APPLICATION <span class="token operator">=</span> <span class="token string">'mysite.routing.application'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    此时Channels可以控制<code>runserver</code>命令，用Channels开发服务器代替标准的Django开发服务器。</p><p>​    运行Django项目：</p><pre class="line-numbers language-powershell"><code class="language-powershell">py manage<span class="token punctuation">.</span>py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    将会看到以下输出：</p><pre class="line-numbers language-powershell"><code class="language-powershell">Performing system checks<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>System check identified no issues <span class="token punctuation">(</span>0 silenced<span class="token punctuation">)</span><span class="token punctuation">.</span>You have 17 unapplied migration<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span> Your project may not work properly <span class="token keyword">until</span> you apply the migrations <span class="token keyword">for</span> app<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: admin<span class="token punctuation">,</span> auth<span class="token punctuation">,</span> contenttypes<span class="token punctuation">,</span> sessions<span class="token punctuation">.</span>Run <span class="token string">'python manage.py migrate'</span> to apply them<span class="token punctuation">.</span>March 07<span class="token punctuation">,</span> 2020 <span class="token operator">-</span> 22:45:04Django version 3<span class="token punctuation">.</span>0<span class="token punctuation">.</span>2<span class="token punctuation">,</span> <span class="token keyword">using</span> settings <span class="token string">'mysite.settings'</span>Starting ASGI<span class="token operator">/</span>Channels version 2<span class="token punctuation">.</span>4<span class="token punctuation">.</span>0 development server at http:<span class="token operator">/</span><span class="token operator">/</span>127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:8000<span class="token operator">/</span>Quit the server with CTRL<span class="token operator">-</span><span class="token keyword">BREAK</span><span class="token punctuation">.</span>HTTP GET <span class="token operator">/</span> 200 <span class="token punctuation">[</span>0<span class="token punctuation">.</span>04<span class="token punctuation">,</span> 127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:54871<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    可以看到<code>Starting ASGI/Channels development server at http://127.0.0.1:8000/</code>，说明Channels开发服务器已从Django开发服务器接管项目。打开<a href="http://127.0.0.1:8000/">初始界面</a>，你将看到熟悉的小火箭：<img src="https://raw.githubusercontent.com/Thooooor/NoteImg/master/20200307225354.png" style="zoom: 80%;"></p><p>​    关闭服务器，创建app<code>event</code>：</p><pre class="line-numbers language-powershell"><code class="language-powershell">py manage<span class="token punctuation">.</span>py startapp event<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注册app：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/settings.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'channels'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 新添加</span>    <span class="token string">'event'</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在<strong>根目录</strong>新建文件夹<code>templates</code>以及<code>templates/event</code>文件夹放置html文件，在<code>mysite/settings.py</code>中添加路径：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/settings.py</span>TEMPLATES <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        <span class="token string">'BACKEND'</span><span class="token punctuation">:</span> <span class="token string">'django.template.backends.django.DjangoTemplates'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true"># 修改</span>        <span class="token string">'DIRS'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">,</span> <span class="token string">'templates'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">'APP_DIRS'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>        <span class="token string">'OPTIONS'</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>            <span class="token string">'context_processors'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">'django.template.context_processors.debug'</span><span class="token punctuation">,</span>                <span class="token string">'django.template.context_processors.request'</span><span class="token punctuation">,</span>                <span class="token string">'django.contrib.auth.context_processors.auth'</span><span class="token punctuation">,</span>                <span class="token string">'django.contrib.messages.context_processors.messages'</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;,</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在<code>templates</code>中添加视图文件<code>event/list.html</code>，其中WebSocket请求部分模板如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">function</span> <span class="token function">Filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"WebSocket"</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//alert("您的浏览器支持WebSocket!");</span>            <span class="token comment" spellcheck="true">// 重定向URL</span>            <span class="token keyword">let</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://"</span><span class="token operator">+</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>host <span class="token operator">+</span> <span class="token string">"/ws/event/list/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ws<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token string">'message'</span><span class="token punctuation">:</span> <span class="token string">"测试"</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// 需要传输的数据</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>evt<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">let</span> received_msg <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">let</span> feed_back <span class="token operator">=</span> received_msg<span class="token punctuation">[</span><span class="token string">'feedback'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">alert</span><span class="token punctuation">(</span>feedback<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 处理接受数据</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            ws<span class="token punctuation">.</span>onclose <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//alert("WebSocket连接已关闭...");</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你的浏览器不支持WebSocket!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    创建视图功能<code>event/views.py</code>：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># event/views.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token keyword">def</span> <span class="token function">list</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'event/list.html'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    创建路由<code>event/urls.py</code>：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># event/urls.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'list/'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>list<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    将<code>event app</code>的路由添加到项目的根路由中：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/urls.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>urls <span class="token keyword">import</span> include<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> adminurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>    path<span class="token punctuation">(</span><span class="token string">'event/'</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'event.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'event'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Channels处理请求过程：</p><pre><code>1. Channels接受HTTP请求 2. 查询根URLconf查找**消费者(consumer)** 3. 在**消费者(consumer)**中调用各种功能来处理连接的事件</code></pre><p>创建**消费者(consumer)**文件<code>event/consumers.py</code>：</p><pre class="line-numbers language-powershell"><code class="language-powershell">event<span class="token operator">/</span>    __init__<span class="token punctuation">.</span>py    ……    consumers<span class="token punctuation">.</span>py    ……    urls<span class="token punctuation">.</span>py    views<span class="token punctuation">.</span>py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    代码模板如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># event/consumers.py</span><span class="token keyword">from</span> channels<span class="token punctuation">.</span>generic<span class="token punctuation">.</span>websocket <span class="token keyword">import</span> WebsocketConsumer<span class="token keyword">import</span> json<span class="token keyword">class</span> <span class="token class-name">ListDataConsumer</span><span class="token punctuation">(</span>WebsocketConsumer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> close_code<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">receive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text_data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 字典化接收数据</span>        text_data_json <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>text_data<span class="token punctuation">)</span>        message <span class="token operator">=</span> text_data_json<span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 数据处理</span>        self<span class="token punctuation">.</span>send<span class="token punctuation">(</span>text_data<span class="token operator">=</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        <span class="token string">'feedback'</span><span class="token punctuation">:</span> <span class="token string">"Accept"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true"># 返回数据</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    为<code>consumers.py</code>配置路由，新建<code>event/routing.py</code>：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># event/routing.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> re_path<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> consumerswebsocket_urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    re_path<span class="token punctuation">(</span>r<span class="token string">'ws/event/list/$'</span><span class="token punctuation">,</span> consumers<span class="token punctuation">.</span>ListDataConsumer<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    接下来将根路由指向<code>event/routing.py</code>文件：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># mysite/routing.py</span><span class="token keyword">from</span> channels<span class="token punctuation">.</span>auth <span class="token keyword">import</span> AuthMiddlewareStack<span class="token keyword">from</span> channels<span class="token punctuation">.</span>routing <span class="token keyword">import</span> ProtocolTypeRouter<span class="token punctuation">,</span> URLRouter<span class="token keyword">import</span> event<span class="token punctuation">.</span>routingapplication <span class="token operator">=</span> ProtocolTypeRouter<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token comment" spellcheck="true"># (http->django views is added by default)</span>    <span class="token string">'websocket'</span><span class="token punctuation">:</span> AuthMiddlewareStack<span class="token punctuation">(</span>        URLRouter<span class="token punctuation">(</span>            event<span class="token punctuation">.</span>routing<span class="token punctuation">.</span>websocket_urlpatterns        <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此根路由配置指定当与Channels开发服务器建立连接时，<code>ProtocolTypeRouter</code>将首先检查连接的类型。如果它是WebSocket连接（<strong>ws：//**或</strong>wss：//**），则该连接将分配给<code>AuthMiddlewareStack</code>。</p><p>​    在<code>AuthMiddlewareStack</code>将填充的连接的<strong>范围</strong>覆盖到当前认证的用户，然后将连接到<code>URLRouter</code>。该<code>URLRouter</code>会研究基础上，提供连接到路由到特定消费者的HTTP路径，基于<code>url</code>模式。</p><p>​    之后进行数据库模型迁移：</p><pre class="line-numbers language-powershell"><code class="language-powershell">py manage<span class="token punctuation">.</span>py makemigrationspy manage<span class="token punctuation">.</span>py migrate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    运行项目：</p><pre class="line-numbers language-powershell"><code class="language-powershell">py manage<span class="token punctuation">.</span>py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    如果连接建立成功，后台应该有如下显示：</p><pre class="line-numbers language-powershell"><code class="language-powershell">HTTP GET <span class="token operator">/</span>event<span class="token operator">/</span>list<span class="token operator">/</span> 200 <span class="token punctuation">[</span>0<span class="token punctuation">.</span>06<span class="token punctuation">,</span> 127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:58855<span class="token punctuation">]</span>WebSocket HANDSHAKING <span class="token operator">/</span>ws<span class="token operator">/</span>event<span class="token operator">/</span>list<span class="token operator">/</span> <span class="token punctuation">[</span>127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:58906<span class="token punctuation">]</span>WebSocket CONNECT <span class="token operator">/</span>ws<span class="token operator">/</span>event<span class="token operator">/</span>list<span class="token operator">/</span> <span class="token punctuation">[</span>127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:58906<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    使用Channels的一般流程如上，在配置ASGI之后，Channels的服务器会替代原有的Django服务器处理请求。</p><p>​    只有在需要使用WebSocket协议进行实时通信时需要配置<code>routing.py</code>和<code>consumers.py</code>，由<code>routing.py</code>指向<code>consumers.py</code>处理WebSocket请求，其余仅使用HTTP协议请求的使用方式与之前并<strong>没有任何区别</strong>。</p><p>​    因为只是在一个项目中的某个app中使用了Channels，可以参考该<a href="https://github.com/Thooooor/GovermentDataAdmin">项目代码</a>中的<code>event</code>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
